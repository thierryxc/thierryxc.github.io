<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="programming self-learner">
<meta property="og:type" content="website">
<meta property="og:title" content="Thierryxc 的博客">
<meta property="og:url" content="http://thierryxc.github.io/page/2/index.html">
<meta property="og:site_name" content="Thierryxc 的博客">
<meta property="og:description" content="programming self-learner">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Thierryxc 的博客">
<meta name="twitter:description" content="programming self-learner">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://thierryxc.github.io/page/2/"/>





  <title>Thierryxc 的博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Thierryxc 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每天进步一点点</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/09/Java异常处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/09/Java异常处理/" itemprop="url">Java异常处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T11:49:18+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>&#160; &#160; &#160; &#160;Java的异常处理（excption-handling）机制是个简洁、轻量化的执行期间例外状况处理方式。它让你能够将处理错误状况的程序代码摆在一个容易阅读的位置。这要依赖你已经知道所调用的方法是有风险的（也就是说方法可能会产生异常），因此你可以编写出处理此可能性的程序代码。如果你知道调用某个方法可能会有异常状况，你就可以预先准备好对问题的处理程序，甚或是从错误中恢复。<br>&#160; &#160; &#160; &#160;知道某个方法是否会抛出异常的方式是看该方法的声明中有没有throws语句。</p>
<h2 id="try-catch块"><a href="#try-catch块" class="headerlink" title="try/catch块"></a>try/catch块</h2><p>try/catch块告诉编译器你确实知道调用的方法有风险，并且也已经准备好处理它。  </p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul>
<li>try中内容成功，不执行catch；</li>
<li>try中不成功，跳过try中剩下部分，直接执行catch；</li>
</ul>
<h3 id="finally：无论如何都要执行的部分"><a href="#finally：无论如何都要执行的部分" class="headerlink" title="finally：无论如何都要执行的部分"></a>finally：无论如何都要执行的部分</h3><ul>
<li>如果try块失败了：抛出异常，流程马上转移到catch块。catch完成后执行finally块。</li>
<li>如果try块成功：跳过catch块，执行finally块。</li>
<li>若try或catch块有return指令，finally块<strong>还是会执行</strong>，流程会调到finally然后再回到return指令。 </li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是一种Exception类型的对象。<br>因为它是对象，所以catch住的也是对象。下面的程序代码中catch的参数是Exception类型的ex引用变量：  </p>
<pre><code>try {
    //危险动作

} catch(Exception ex) {
    //尝试恢复

}
</code></pre><p>写在catch块中的程序必定与所抛出的异常有关。</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>当你的程序代码调用有风险的方法时（也就是声明有异常的方法），就是该方法抛出异常。</p>
<h3 id="有风险、会抛出异常的程序代码："><a href="#有风险、会抛出异常的程序代码：" class="headerlink" title="有风险、会抛出异常的程序代码："></a>有风险、会抛出异常的程序代码：</h3><pre><code>public void takeRisk() throws BadException { //必须要声明它会抛出BadException
    if (abandonAllHope) {
        throw new BadException(); //创建Exception对象并抛出
    }
}
</code></pre><h3 id="调用该方法的程序代码："><a href="#调用该方法的程序代码：" class="headerlink" title="调用该方法的程序代码："></a>调用该方法的程序代码：</h3><pre><code>public void crossFingers() {
    try {
        anObject.takeRisk();
    } catch (BadException ex) {
        System.out.println(&quot;Aaargh!&quot;);
        ex.printStackTrace(); //调用此方法列出有用的信息
        }
}
</code></pre><p><strong>方法可以抓住其他方法所抛出的异常。异常总是丢回给调用方。</strong><br><strong>会抛出异常的方法必须要声明它有可能会这么做。</strong>  </p>
<h3 id="抛出一个以上异常"><a href="#抛出一个以上异常" class="headerlink" title="抛出一个以上异常"></a>抛出一个以上异常</h3><p>方法可以抛出多个异常，但在该方法的声明里必须要含有全部可能的检查异常（若两个或两个以上的异常有共同的父类时，可以只声明该父类）：</p>
<pre><code>public class Laundry {
    public void doLaundry() throws PantsException, LingerieException {
        //有可能抛出两个异常的程序代码

    }
}
</code></pre><hr>
<pre><code>public class Foo {
    public void go() {
        Laundry laundry = new Laundry();
        try {
            laundry.doLaundry();
        } catch(PantsException pex) {
            //恢复程序代码
        } catch(LingerieException lex) {
            //恢复程序代码
        }
    }
}
</code></pre><h2 id="异常也是多态的"><a href="#异常也是多态的" class="headerlink" title="异常也是多态的"></a>异常也是多态的</h2><p>如果处理各子类型异常方式不同，要单独编写，如果相同，则可以编写一个父类型的处理方式。</p>
<p>在处理多态问题时要把子类异常写在前面，因为一旦程序catch了父类异常，就不会再管其他子类异常。</p>
<h1 id="不想处理异常"><a href="#不想处理异常" class="headerlink" title="不想处理异常"></a>不想处理异常</h1><p>方法：继续抛出异常</p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170809_133715.jpg" alt="duck"></p>
<h1 id="小结：两种处理异常的方式"><a href="#小结：两种处理异常的方式" class="headerlink" title="小结：两种处理异常的方式"></a>小结：两种处理异常的方式</h1><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170809_133741.jpg" alt="小结"></p>
<h1 id="异常处理规则"><a href="#异常处理规则" class="headerlink" title="异常处理规则"></a>异常处理规则</h1><ol>
<li>catch与finally不能没有try；</li>
<li>try与catch之间不能有程序；</li>
<li>try一定要有catch或finally；</li>
<li>只带有finally的try必须要声明异常；</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/08/Java日期和时间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/08/Java日期和时间/" itemprop="url">Java日期和时间</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T14:33:01+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h1><h2 id="取得当前的日期用Date"><a href="#取得当前的日期用Date" class="headerlink" title="取得当前的日期用Date"></a>取得当前的日期用Date</h2><pre><code>import java.util.Date;
    public class DateTest {

        public static void main(String[] args) {
            //完整的日期与时间：%tc
            String s = String.format(&quot;%tc&quot;, new Date());
            System.out.println(s);

            //只有时间：%tr
            s = String.format(&quot;%tr&quot;, new Date());
            System.out.println(s);

            //周、月、日：%tA %tB %td
            Date today = new Date();
            s = String.format(&quot;%tA %tB %td&quot;, today, today, today);
            System.out.println(s);

            //不用重复给参数
            s = String.format(&quot;%tA %&lt;tB %&lt;td&quot;, today);
            System.out.println(s);
        }

}
</code></pre><p>输出：  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/date.png" alt="Date"></p>
<h2 id="操作日期用Calendar"><a href="#操作日期用Calendar" class="headerlink" title="操作日期用Calendar"></a>操作日期用Calendar</h2><h3 id="取得继承过Calendar的对象"><a href="#取得继承过Calendar的对象" class="headerlink" title="取得继承过Calendar的对象"></a>取得继承过Calendar的对象</h3><p>Calendar的实例无法取得，但是可以取得它的具体子类的实例：  </p>
<pre><code>Calendar cal = Calendar.getInstance();
</code></pre><h3 id="运用Calendar对象"><a href="#运用Calendar对象" class="headerlink" title="运用Calendar对象"></a>运用Calendar对象</h3><h4 id="几个关键概念："><a href="#几个关键概念：" class="headerlink" title="几个关键概念："></a>几个关键概念：</h4><ul>
<li>字段会保存状态：Calendar对象使用许多字段来表示某些事物的最终状态，也就是日期和时间。</li>
<li>日期和时间可以运算：Calendar的方法能够让你对不同的字段做加法或减法的运算，比如说对month字段加一个月。</li>
<li>日期与时间可以用millisecond来表示：Calendar可以让你将日期转换成微秒的表示法，或将微秒转换成日期。（相对于1970.1.1的微秒数），因此可以执行精确的相对计算。</li>
</ul>
<h4 id="运用Calendar对象："><a href="#运用Calendar对象：" class="headerlink" title="运用Calendar对象："></a>运用Calendar对象：</h4><pre><code>import java.util.Calendar;
public class CalendarTest {

    public static void main(String[] args) {
        Calendar c = Calendar.getInstance();
        c.set(2017,8,8,16,27);
        long day1 = c.getTimeInMillis();
        day1 += 1000 * 60 * 60;
        c.setTimeInMillis(day1);
        System.out.println(&quot;New hour &quot; + c.get(c.HOUR_OF_DAY));
        c.add(c.DATE, 35);
        System.out.println(&quot;add 35 days &quot; + c.getTime());
        c.roll(c.DATE, 35);
        System.out.println(&quot;roll 35 days &quot; + c.getTime());    
        c.set(c.DATE, 1);
        System.out.println(&quot;set to 1 &quot; + c.getTime());

    }

}
</code></pre><hr>
<p>输出：  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/calendar.png" alt="Calendar"></p>
<h4 id="常用的Calendar方法、字段"><a href="#常用的Calendar方法、字段" class="headerlink" title="常用的Calendar方法、字段"></a>常用的Calendar方法、字段</h4><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170808_175022.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/08/Java静态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/08/Java静态/" itemprop="url">Java静态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T12:07:16+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><p>Java是面向对象的，但若处于某种特殊情况下（通常是实用方法），则不需要类的实例。<strong>static</strong>这个关键词可以标记出不需类实例的方法。一个静态的方法就是不需要实例变量、不需要对象的行为。</p>
<h2 id="带有静态方法的含义"><a href="#带有静态方法的含义" class="headerlink" title="带有静态方法的含义"></a>带有静态方法的含义</h2><p>带有静态方法的类通常不打算要被初始化。<br>想要不让类被初始化可以有两种途径：  </p>
<ul>
<li>用abstract标记类。抽象的类不能被初始化。</li>
<li>用私有的<strong>构造函数</strong>来限制非抽象类被初始化（Math防止被初始化的方法）。  </li>
</ul>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>Math方法不需要创建Math实例就可使用，我们用的是类本身。  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170808_124552.jpg" alt="Math"></p>
<h1 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h1><p>静态变量的值对所有<strong>实例</strong>来说都相同，静态变量是被同类的所有实例共享的变量。<br>静态变量会在该类的任何<strong>静态方法</strong>执行前就初始化。（默认值与实例变量相同）  </p>
<hr>
<pre><code>public class Duck {
    private int size;
    public static int duckCount = 0;

    public Duck() {
        duckCount++;
        size = 20;
    }


    public static void main(String[] args) {
        System.out.println(Duck.duckCount);//实例创建前
        Duck d1 = new Duck();

        //类和类的实例共享静态变量

        System.out.println(d1.duckCount);
        Duck d2 = new Duck();
        System.out.println(Duck.duckCount);
        Duck d3= new Duck();
        System.out.println(d2.duckCount);
    }
}
</code></pre><hr>
<p>输出：</p>
<pre><code>0
1
2
3
</code></pre><hr>
<h2 id="静态的final变量是常量"><a href="#静态的final变量是常量" class="headerlink" title="静态的final变量是常量"></a>静态的final变量是常量</h2><p>一个被标记为final的变量代表它一旦被初始化之后就不会改动，也就是说类加载之后静态final变量就一直维持原值。以Math.PI为例：  </p>
<pre><code>public static final double PI = 3.141592653589793；
</code></pre><ul>
<li>此变量被标记为public，因此可供各方读取。</li>
<li>此变量被标记为static，不需要Math实例。</li>
<li>此变量被标记为final，其值不可改变。</li>
</ul>
<h3 id="静态final变量的初始化："><a href="#静态final变量的初始化：" class="headerlink" title="静态final变量的初始化："></a>静态final变量的初始化：</h3><p><strong>静态final变量必须人工初始化。</strong></p>
<h4 id="声明的时候"><a href="#声明的时候" class="headerlink" title="声明的时候"></a>声明的时候</h4><pre><code>public class Foo {
    public static final int FOO_X = 20；
}
</code></pre><h4 id="在静态初始化程序中"><a href="#在静态初始化程序中" class="headerlink" title="在静态初始化程序中"></a>在静态初始化程序中</h4><p>静态初始化程序是一段在加载类时会执行的程序代码，它会在其它程序可以调用该类之前就执行，所以很适合放静态final变量的起始程序。  </p>
<pre><code>public class Foo {
    public static final int FOO_X；
    static {//这段程序在类被加载时执行
        FOO_X = 20；
    }
}
</code></pre><h2 id="非静态final变量"><a href="#非静态final变量" class="headerlink" title="非静态final变量"></a>非静态final变量</h2><ul>
<li>final的变量代表不能改变它的值。</li>
<li>final的方法不能被覆盖。</li>
<li>final的类不能被继承。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/07/Java构造函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/Java构造函数/" itemprop="url">Java构造函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T13:53:18+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h1><ul>
<li>栈与堆是两种Java使用的内存空间;</li>
<li>实例变量是声明在类中方法之外的地方;</li>
<li>局部变量声明在方法或方法的参数上;</li>
<li>所有局部变量都存在于栈上相对应的堆栈块中;</li>
<li>对象引用变量与primitive主数据类型变量都放在栈上;</li>
<li>不管是实例变量或局部变量，对象本身都会在堆上;</li>
</ul>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul>
<li>构造函数带有你在初始化对象时会执行的程序代码。也就是新建一个对象时就会被执行。</li>
<li>就算没有自己写构造函数，编译器也会帮你写一个（无参数，无内容的）。  </li>
</ul>
<hr>
<pre><code>public class Duck {
    int size;

    public Duck() { //没有返回类型
        size = 27; //使用默认值
    }

    public Duck(int duckSize) {
        size = duckSize;//使用参数设定
    }

    public static void main(String[] args) {
        Duck d1 = new Duck();
        Duck d2 = new Duck(24);

        System.out.println(&quot;The size of d1 is &quot; + d1.size);
        System.out.println(&quot;The size of d2 is &quot; + d2.size);

    }
}
</code></pre><p>输出：  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/duck.png" alt="duck"></p>
<p>这个构造函数是重载的。  </p>
<p>重载构造函数的意思是代表你有一个以上的构造函数且参数都不相同。（编译器只关注参数的<strong>类型和顺序</strong>，参数的名字不重要）  </p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>实例变量保存在所属的对象中，位于堆上。</li>
<li>如果实例变量是个对对象的引用，则引用与对象都在堆上。</li>
<li>构造函数是在新建对象时执行的程序代码。</li>
<li>构造函数必须与类同名且没有返回类型。</li>
<li>可以用构造函数来初始化被创建对象的状态。</li>
<li>如果不写构造函数，编译器会自己创建一个，默认的构造函数没有参数。</li>
<li>实例变量有默认值，原始的是0/0.0/false，引用的默认值是null。</li>
</ul>
<h2 id="父类和继承与构造函数的关系"><a href="#父类和继承与构造函数的关系" class="headerlink" title="父类和继承与构造函数的关系"></a>父类和继承与构造函数的关系</h2><p>在创建新对象时，<strong>所有</strong>继承下来的构造函数都会执行。构造函数在执行的时候，第一件事是去执行他的父类的构造函数，一直连锁反映到Object类为止。  </p>
<h3 id="无参数的父类构造函数调用"><a href="#无参数的父类构造函数调用" class="headerlink" title="无参数的父类构造函数调用"></a>无参数的父类构造函数调用</h3><hr>
<pre><code>public class Animal {
    public Animal() {
        System.out.println(&quot;Making an animal.&quot;);
    }
}
</code></pre><hr>
<pre><code>public class Hippo extends Animal {
    public Hippo() {
        System.out.println(&quot;Making an Hippo.&quot;);
    }
}
</code></pre><hr>
<pre><code>public class TestHippo {
    public static void main(String[] args) {
        Hippo h = new Hippo();
    }
}
</code></pre><hr>
<p><img src="http://osakbqq1v.bkt.clouddn.com/super.png" alt="super"> </p>
<p>上面的例子是调用无参数的父类构造函数，可以交给编译器自行完成。  </p>
<h3 id="有参数的父类构造函数调用"><a href="#有参数的父类构造函数调用" class="headerlink" title="有参数的父类构造函数调用"></a>有参数的父类构造函数调用</h3><hr>
<pre><code>public  abstract class Animal {
    private String name;

    public String getName() {
        return name;
    }
    public Animal(String theName) {
        name = theName;
    }
}
</code></pre><hr>
<pre><code>public class Hippo extends Animal {
    public Hippo(String name) {//这个构造函数要求名称
        super(name);//传给Animal的构造函数

    }
}
</code></pre><hr>
<pre><code>public class TestHippo {

    public static void main(String[] args) {
        Hippo h = new Hippo(&quot;Buffy&quot;);
        System.out.println(h.getName());
    }

}
</code></pre><hr>
<p>输出：  </p>
<pre><code>Buffy
</code></pre><h3 id="this-函数"><a href="#this-函数" class="headerlink" title="this()函数"></a>this()函数</h3><ul>
<li>使用this()来从某个构造函数中调用同一个类的另外一个构造函数。</li>
<li>this()只能用在构造函数中，且必须是第一行语句。</li>
<li>super()与this()不能同时用。每个构造函数可以选择调用super()或this(),但不能同时调用。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/04/Java继承、接口与多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/Java继承、接口与多态/" itemprop="url">Java继承、接口与多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-04T19:27:13+08:00">
                2017-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>子类是extends父类出来的。</li>
<li>子类会继承父类所有public类型的实例变量和方法，但不会继承父类任何的private类型的实例变量和方法。</li>
<li>继承下来的方法可以被覆盖掉，但<strong>实例变量</strong>不能被覆盖。即是某个方法在子类中被覆盖过，调用时会使用覆盖过的版本。如果覆盖后想调用父类的方法，就要用super.method()。  </li>
</ul>
<h2 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h2><ul>
<li>通过提取出类间共同的抽象性，可以排除重复的程序代码而将这个部分放在父类中。这样如果有<strong>共同</strong>的部分需要改动，就只会有一个地方改动，所有子类共享。</li>
<li>继承可以确保某个父型之下的所有类都会有父型所持有的全部（可遗传的）方法，即通过继承来定义相关类间的共同协议。  </li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="回顾：一般声明引用和创建对象的方法"><a href="#回顾：一般声明引用和创建对象的方法" class="headerlink" title="回顾：一般声明引用和创建对象的方法"></a>回顾：一般声明引用和创建对象的方法</h2><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170805_132042.jpg" alt="多态1">  </p>
<h2 id="多态的运用"><a href="#多态的运用" class="headerlink" title="多态的运用"></a>多态的运用</h2><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170805_132049.jpg" alt="多态2"></p>
<p>运用多态时，引用类型可以是实际对象的<strong>父类</strong>。  </p>
<p>在方法中，参数的引用类型也可以是实际参数的<strong>父类</strong>。  </p>
<p>综上所述，通过多态，可以编写出引进新型子类也不必修改的程序。   </p>
<h2 id="覆盖的规则"><a href="#覆盖的规则" class="headerlink" title="覆盖的规则"></a>覆盖的规则</h2><p>要覆盖父类的方法时：  </p>
<ul>
<li>参数必须要一样，且返回类型必须要兼容</li>
<li>不能<strong>降低</strong>方法的存取权限  </li>
</ul>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>重载只是刚好有相同名字的<strong>不同</strong>方法，与继承和多态无关。  </p>
<h1 id="接口和多态"><a href="#接口和多态" class="headerlink" title="接口和多态"></a>接口和多态</h1><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><h3 id="声明抽象类"><a href="#声明抽象类" class="headerlink" title="声明抽象类"></a>声明抽象类</h3><pre><code>abstarct public class Canine extends Animal
{
    public void roam() { }
}
</code></pre><hr>
<pre><code>public class MakeCanine {
    public void go() {
        Canine c;  //这是可以的，使用抽象类型来声明为引用类型给多态使用
        c = new dog();
        c = new Canine();//编译器不通过：无法创建出抽象类的实例
        c.roam() 
    }
}
</code></pre><p><strong>抽象类除了被继承过之外，没有用途、没有值、没有目的。</strong>  </p>
<h3 id="抽象的方法"><a href="#抽象的方法" class="headerlink" title="抽象的方法"></a>抽象的方法</h3><p>可以将方法标记为abstract，抽象的类表明该类一定被继承过，抽象的方法一定要被覆盖过。  </p>
<p><strong>抽象的方法没有实体。</strong>  </p>
<pre><code>public abstract void eat();
</code></pre><p><strong>如果在一个类中声明了任何一个抽象的方法，就必须将该类也标记成抽象的。</strong>  </p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的源头，它是所有类的父类。  </p>
<h3 id="Object类中带有的部分方法"><a href="#Object类中带有的部分方法" class="headerlink" title="Object类中带有的部分方法"></a>Object类中带有的部分方法</h3><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170806_194641.jpg" alt="Object方法"></p>
<h3 id="使用Object多态"><a href="#使用Object多态" class="headerlink" title="使用Object多态"></a>使用Object多态</h3><pre><code>ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();
Dog aDog = new Dog();
myDogArrayList.add(aDog);

Dog d = myDogArrayList.get(0) //无法通过编译！！！不管add进去的值是什么类型的，从ArrayList&lt;Object&gt;取出的值引用类型均为Object！！！  
</code></pre><h2 id="接口（类似于纯抽象类）"><a href="#接口（类似于纯抽象类）" class="headerlink" title="接口（类似于纯抽象类）"></a>接口（类似于纯抽象类）</h2><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><pre><code>public interface Pet {
    public abstract void beFriendly();
    public abstract void Play();
}
</code></pre><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><pre><code>public class Dog extends Canine implement Pet {
    public void beFriendly() {……} //必须实现出Pet的方法
    public  void Play(){……} //必须实现出Pet的方法

    ……
}
</code></pre><h3 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h3><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170806_200840.jpg" alt="接口">  </p>
<p>意义还是在于<strong>多态</strong>，用接口取代具体的子类或抽象的父类作为参数或返回类型，则可以传入任何实现该接口的东西，使用接口可以继承超过一个以上的来源。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/03/Java编写程序-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/Java编写程序-2/" itemprop="url">Java编写程序(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T18:35:44+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h1><p><img src="http://osakbqq1v.bkt.clouddn.com/simpledc.png" alt="bug">  </p>
<p>在简单版本的程序中，玩家只要猜中任意一格，计数器就+1，而没有考虑是否这一格是否被猜中过。  </p>
<h1 id="使用ArrayList"><a href="#使用ArrayList" class="headerlink" title="使用ArrayList"></a>使用ArrayList</h1><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_0543.JPG" alt="arraylist">  </p>
<h1 id="游戏的完全版"><a href="#游戏的完全版" class="headerlink" title="游戏的完全版"></a>游戏的完全版</h1><h2 id="需要改变的类"><a href="#需要改变的类" class="headerlink" title="需要改变的类"></a>需要改变的类</h2><ul>
<li>DotCom类要增加名称变量来区别不同的网站；</li>
<li>游戏的类（DotComBust）：要创建三个DotCom并指定他们的名称、将DotCom放在方阵上（GameHelper实现）、每次猜测检查3个DotCom、击沉3个DotCom后才结束游戏、脱离main()；</li>
<li>辅助性类；</li>
</ul>
<h2 id="DotCom类"><a href="#DotCom类" class="headerlink" title="DotCom类"></a>DotCom类</h2><pre><code>import java.util.*;
public class DotCom {
    private ArrayList&lt;String&gt; locationCells; //保存位置的ArrayList
    private String name;

    public void setLocationCells(ArrayList&lt;String&gt; loc) { //更新位置的方法
        locationCells = loc;
    }

    public void setName(String n) {
        name = n;
    }

    public String checkYourself(String userInput) {
        String result = &quot;miss&quot;;
        int index = locationCells.indexOf(userInput);//把玩家输入坐标的下标赋给index，没找到返回-1
        if (index &gt;= 0) {
            locationCells.remove(index);


            if (locationCells.isEmpty()) {
                result = &quot;kill&quot;;
                System.out.println(&quot;Oh! You sunk &quot; + name);
            } else {
                result = &quot;hit&quot;;
             }    
        }    
        return result;
    }
}
</code></pre><h2 id="DotComBust类的伪码"><a href="#DotComBust类的伪码" class="headerlink" title="DotComBust类的伪码"></a>DotComBust类的伪码</h2><pre><code>声明GameHelper实例helper；
声明一个ArrayList实例dotComList来放置三个网站；
声明一个int类型的变量NumOfGuess来记录玩家猜测次数，初始化为0；
</code></pre><hr>
<pre><code>声明setUpGame()方法：创建并初始化三个DotCom实例，并分别取名，放置到方阵上，给玩家一个简短的介绍；
声明startPlaying()方法：重复询问并获取玩家猜测，调用checkUserGuess()方法，直到所有DotCom被移除；
声明checkUserGuess()方法：遍历所有DotCom实例，并让他们调用自身checkYourself()方法；
声明finishGame()方法：基于猜测次数输出玩家成绩；
</code></pre><hr>
<pre><code>void setUpGame()
    创建三个DotCom实例；
    分别命名；
    把它们加入dotComList；
    遍历dotComList：
        调用placeDotCom()方法（helper实例中），初始化三个网站位置；
        用DotCom的setLocationCells()设定位置；

void start playing()
    while (dotComList中还有元素)：
        调用helper中的getUserInput()方法获取玩家猜测；
        调用checkUserGuess()方法验证猜测；

void checkUserGuess()
    numOfGuess++;
    声明并设置局部变量result为&quot;miss&quot;；
    遍历dotComList：
        调用checkYourself()方法来验证玩家猜测；
        在需要的情况下改变result为&quot;hit&quot;或&quot;kill&quot;；
        if (result == &quot;kill&quot;)
                从dotComList移除该实例；
    显示result值；

void finishGame()
    显示gameover
    if 猜测数少：
        祝贺的信息
    else：
        继续努力的信息
</code></pre><h2 id="编写测试方法的代码"><a href="#编写测试方法的代码" class="headerlink" title="编写测试方法的代码"></a>编写测试方法的代码</h2><p>最重要的方法是checkUserGuess()：初始化一个网站，假定网站位置和用户猜测来测试方法。<br>其次是初始化的setUpGame()：可以打印出设置的信息来查看（在DotCom类中增加方法）。<br>剩余两个方法实现比较简单，个人认为不需要专门的测试。  </p>
<hr>
<p>下面是自己写的测试代码：  </p>
<pre><code>import java.util.*;
public class MethodTestDrive {

    public static void main(String[] args) {
        System.out.println(&quot;Testing setUpGame()...&quot;);
            DotComBust game1 = new DotComBust();
        game1.setUpGames();
        for (DotCom x : game1.dotComsList) {
            System.out.println(x.getName() + &quot; postion: &quot; + x.getLocationCells());
        }
        System.out.println(&quot;Testing chekUserGuess()...&quot;);
        DotComBust game2 = new DotComBust();
        DotCom d1 = new DotCom();
        d1.setName(&quot;163.com&quot;);
        ArrayList&lt;String&gt; pos = new ArrayList&lt;String&gt;();
        pos.add(&quot;C5&quot;);
        pos.add(&quot;C6&quot;);
        pos.add(&quot;C7&quot;);
        d1.setLocationCells(pos);
        game2.dotComsList.add(d1);
        System.out.println(&quot;Result should be \&quot;miss\&quot; \&quot;hit\&quot; \&quot;hit\&quot; \&quot;kill\&quot; &quot;);
        game2.checkUserGuess(&quot;C4&quot;);
        game2.checkUserGuess(&quot;C5&quot;);
        game2.checkUserGuess(&quot;C6&quot;);
        game2.checkUserGuess(&quot;C7&quot;);
        System.out.println(&quot;Number of guesses: &quot; + game2.numOfGuesses);

    }

}
</code></pre><h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><pre><code>import java.util.*;

public class DotComBust {
    private GameHelper helper = new GameHelper();
    private ArrayList&lt;DotCom&gt; dotComsList = new ArrayList&lt;DotCom&gt;();
    private int numOfGuesses = 0;

    private void setUpGames() {
        DotCom one = new DotCom();
        one.setName(&quot;Pets.com&quot;);
        DotCom two = new DotCom();
        two.setName(&quot;qq.com&quot;);
        DotCom three = new DotCom();
        three.setName(&quot;163.com&quot;);
        dotComsList.add(one);
        dotComsList.add(two);
        dotComsList.add(three);

        System.out.println(&quot;共有三个网站，尝试用最少的次数打掉他们！&quot;);

        for (DotCom dotComToSet : dotComsList) {
            ArrayList&lt;String&gt; newLocation = helper.placeDotCom(3);

            dotComToSet.setLocationCells(newLocation);
        }
    }

    private void startPlaying() {
        while (!dotComsList.isEmpty()) {
            String userGuess = helper.getUserInput(&quot;Enter a guess&quot;);
            checkUserGuess(userGuess);
        }

        finishGame();
    }

    private void checkUserGuess(String userGuess) {
        numOfGuesses++;
        String result = &quot;miss&quot;;
        for (DotCom dotComToTest : dotComsList) {
            result = dotComToTest.checkYourself(userGuess);
            if (result.equals(&quot;hit&quot;)) {
                break;
            }
            if (result.equals(&quot;kill&quot;)) {
                dotComsList.remove(dotComToTest);
                break;
            }

        }
        System.out.println(result);
    }    

    private void finishGame() {
        System.out.println(&quot;你打掉了所有网站！&quot;);
        if (numOfGuesses &lt;= 18) {
            System.out.println(&quot;你只用了&quot; + numOfGuesses + &quot;次！&quot; );
        } else {
            System.out.println(&quot;你用了&quot; + numOfGuesses + &quot;次！次数太多了&quot; );
        }

    }

    public static void main(String[] args) {
        DotComBust game = new DotComBust();
        game.setUpGames();
        game.startPlaying();
    }
}
</code></pre><ul>
<li>程序中除了main都是<strong>private</strong>，很好地保护了数据。</li>
</ul>
<h2 id="GameHelper"><a href="#GameHelper" class="headerlink" title="GameHelper"></a>GameHelper</h2><pre><code>import java.io.*;
import java.util.*;

public class GameHelper {

  private static final String alphabet = &quot;abcdefg&quot;;
  private int gridLength = 7;
  private int gridSize = 49;
  private int [] grid = new int[gridSize];
  private int comCount = 0;


  public String getUserInput(String prompt) {
     String inputLine = null;
     System.out.print(prompt + &quot;  &quot;);
     try {
       BufferedReader is = new BufferedReader(
     new InputStreamReader(System.in));
       inputLine = is.readLine();
       if (inputLine.length() == 0 )  return null; 
     } catch (IOException e) {
       System.out.println(&quot;IOException: &quot; + e);
     }
     return inputLine.toLowerCase();
  }



  public ArrayList&lt;String&gt; placeDotCom(int comSize) {                 // line 19
    ArrayList&lt;String&gt; alphaCells = new ArrayList&lt;String&gt;();
    String [] alphacoords = new String [comSize];      // holds &apos;f6&apos; type coords
    String temp = null;                                // temporary String for concat
    int [] coords = new int[comSize];                  // current candidate coords
    int attempts = 0;                                  // current attempts counter
    boolean success = false;                           // flag = found a good location ?
    int location = 0;                                  // current starting location

    comCount++;                                        // nth dot com to place
    int incr = 1;                                      // set horizontal increment
    if ((comCount % 2) == 1) {                         // if odd dot com  (place     vertically)
          incr = gridLength;                               // set vertical increment
    }

    while ( !success &amp; attempts++ &lt; 200 ) {             // main search loop  (32)
        location = (int) (Math.random() * gridSize);      // get random starting point
        //System.out.print(&quot; try &quot; + location);
        int x = 0;                                        // nth position in dotcom to place
        success = true;                                 // assume success
        while (success &amp;&amp; x &lt; comSize) {                // look for adjacent unused spots
          if (grid[location] == 0) {                    // if not already used
             coords[x++] = location;                    // save location
             location += incr;                          // try &apos;next&apos; adjacent
             if (location &gt;= gridSize){                 // out of bounds - &apos;bottom&apos;
               success = false;                         // failure
             }
             if (x&gt;0 &amp; (location % gridLength == 0)) {  // out of bounds - right edge
               success = false;                         // failure
             }
          } else {                                      // found already used location
              // System.out.print(&quot; used &quot; + location);  
              success = false;                          // failure
          }
        }
    }                                                   // end while

    int x = 0;                                          // turn good location into     alpha coords
    int row = 0;
    int column = 0;
    // System.out.println(&quot;\n&quot;);
    while (x &lt; comSize) {
      grid[coords[x]] = 1;                              // mark master grid pts. as     &apos;used&apos;
      row = (int) (coords[x] / gridLength);             // get row value
      column = coords[x] % gridLength;                  // get numeric column value
      temp = String.valueOf(alphabet.charAt(column));   // convert to alpha

      alphaCells.add(temp.concat(Integer.toString(row)));
      x++;

      // System.out.print(&quot;  coord &quot;+x+&quot; = &quot; + alphaCells.get(x-1));

    }
    // System.out.println(&quot;\n&quot;);

    return alphaCells;
  }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/03/Java编写程序-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/Java编写程序-1/" itemprop="url">Java编写程序(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T11:47:18+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="编写一个程序的流程"><a href="#编写一个程序的流程" class="headerlink" title="编写一个程序的流程"></a>编写一个程序的流程</h1><h2 id="程序概述"><a href="#程序概述" class="headerlink" title="程序概述"></a>程序概述</h2><p>棋盘类战舰游戏，猜测对方战舰的坐标，然后轮流开炮攻击，命中数发就可以打沉战舰。<br>用网站名代替战舰：  </p>
<ul>
<li>游戏目标：以最少的猜测次数打掉计算机所安排的网站。</li>
<li>初始设置：计算机在虚拟的7*7方格上安排3个网站。安排完成后，游戏要求玩家开始猜坐标。</li>
<li>进行游戏：玩家输入坐标，计算机反馈”miss”（未命中）、”hit”（命中）或”kill”（击沉）等回应。当玩家打掉所有网站时，游戏计算分数并结束。  </li>
</ul>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_0540.JPG" alt="游戏示意">  </p>
<h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><h3 id="高层设计"><a href="#高层设计" class="headerlink" title="高层设计"></a>高层设计</h3><p>首先要了解游戏流程：  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_0541.JPG" alt="游戏流程">    </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_0542.JPG" alt="流程图">  </p>
<p>了解了游戏流程后，下面要设想需要哪些<strong>对象</strong>。要用面向对象的方式来思考；<strong>专注于程序中出现的事物而不是过程</strong>。  </p>
<h3 id="简单的开始"><a href="#简单的开始" class="headerlink" title="简单的开始"></a>简单的开始</h3><p>至少需要两个类：Game类和DotCom类。<br>先从一个简单版本开始开发：只使用横列，只设置一个网站。<br>简单版也需要具有完全版的基本功能，是开发完全版的踏脚石。  </p>
<h3 id="开发类"><a href="#开发类" class="headerlink" title="开发类"></a>开发类</h3><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul>
<li>找出类应该做的事；</li>
<li>列出实例变量和方法；</li>
<li>编写方法的伪码；</li>
<li>编写方法的测试用程序；</li>
<li>实现类；</li>
<li>测试方法；</li>
<li>除错或重新设计。  </li>
</ul>
<h4 id="编写伪码"><a href="#编写伪码" class="headerlink" title="编写伪码"></a>编写伪码</h4><p>伪码是用近似编程的语言对程序进行描述，Java伪码大致有三个部分：  </p>
<ol>
<li>实例变量的声明；</li>
<li>方法的声明：</li>
<li><strong>方法的逻辑</strong>（最重要）  </li>
</ol>
<h5 id="SimpleDotCom类的伪码"><a href="#SimpleDotCom类的伪码" class="headerlink" title="SimpleDotCom类的伪码"></a>SimpleDotCom类的伪码</h5><pre><code>声明 一个int数组loctionCells来存储位置信息。
声明 一个int类型的数字变量numOfHits来记录打中的数目，初始化为0。

声明 checkYourself()方法，接收一个String类型输入（玩家猜测），与网站坐标比对后返回&quot;hit&quot;,&quot;miss&quot;或&quot;kill&quot;。
声明 setLocationCells()方法来获得网站的位置信息（接收一个i内含3个元素的int类型数组）

String checkYourself(String userGuess)
    接受玩家输入（字符串形式）
    将字符串转换成int
    遍历loctionCells存储的坐标
        比较玩家的猜测和loctionCells存储的坐标
        if 两者相同
            numOfHits++
            观察玩家的猜测是否是loctionCells中最后一个坐标元素
            if numOfHits是3，返回&quot;kill&quot;，跳出循环。
            else 返回&quot;hit&quot;
        else
            没猜中，返回&quot;miss&quot;

void setLocationCells(int[] cellLocations)
    接受一个int类型数组作为输入
    将实例变量loctionCells设为输入的数组
</code></pre><h4 id="编写测试方法用的程序代码"><a href="#编写测试方法用的程序代码" class="headerlink" title="编写测试方法用的程序代码"></a>编写测试方法用的程序代码</h4><p>目的：更容易更快的写出程序代码。  </p>
<p>对于SimpleDotCom类来说，主要需要测试的就是checkYourself()这个方法，这就需要能创建并初始化一个SimpleDotCom类的对象，然后给它一个初始坐标（setLocationCells()），列出结果来观察是否正确。  </p>
<h5 id="SimpleDotCom的测试码"><a href="#SimpleDotCom的测试码" class="headerlink" title="SimpleDotCom的测试码"></a>SimpleDotCom的测试码</h5><pre><code>public class SimpleDotComTestDrive {

    public static void main(String[] args) {
        SimpleDotCom dot = new SimpleDotCom();//初始化一个对象

        int[] locations = {2,3,4};
        dot.setLocationCells(locations);//调用setter

        String userGuess = &quot;2&quot;;//假的猜测
        String result = dot.checkYourself(userGuess);//调用被测方法并传入假的数据    
    }    

}  
</code></pre><h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><pre><code>public class SimpleDotCom {
    int[] locationCells;
    int numOfHits = 0;

    public void setLocationCells(int[] locs) {
        locationCells = locs;
    }

    public String checkYourself(String stringGuess) {
        int guess = Integer.parseInt(stringGuess);//字符串变为int
        String result = &quot;miss&quot;;
        for (int cell : locationCells) {
            if (guess == cell) {
                result = &quot;hit&quot;;
                numOfHits++;
                break;
            }
        }

        if (numOfHits == locationCells.length) {
            result = &quot;kill&quot;;
        }
        System.out.println(result);
        return result;
    }
}
</code></pre><h4 id="编写SimpleDotComGame类的伪码"><a href="#编写SimpleDotComGame类的伪码" class="headerlink" title="编写SimpleDotComGame类的伪码"></a>编写SimpleDotComGame类的伪码</h4><pre><code>public static void main (String[] args)
    声明int类型变量numOfGuess来储存玩家猜测次数，初始化为0
    初始化一个SimpleDotCom实例
    获取0-4的一个随机数来作为网站的第一个位置坐标
    声明一个3元素int数组来存放生成的随机位置（由上面获得的随机数递增）
    将位置用setter赋给SimpleDotCom实例
    声明一个boolean变量isAlive来控制游戏进程，初始化为true
    while (isAlive == true):
        获取用户输入
        调用checkYourself()方法
        numOfGuess++
        if （result是&quot;kill&quot;）
                isAlive设为false
                打印numOfGuess
</code></pre><h4 id="游戏的main-方法"><a href="#游戏的main-方法" class="headerlink" title="游戏的main()方法"></a>游戏的main()方法</h4><pre><code>public class SimpleDotComGame {

    public static void main(String[] args) {
        int numOfGuess = 0;

        GameHelper helper = new GameHelper();

        SimpleDotCom theDotCom = new SimpleDotCom();
        int randomNum = (int) (Math.random() * 5);

        int[] locations = {randomNum, randomNum+1, randomNum+2};
        theDotCom.setLocationCells(locations);
        boolean isAlive = true;

        while (isAlive == true) {
            String guess = helper.getUserInput(&quot;enter a number&quot;);
            String result = theDotCom.checkYourself(guess);
            numOfGuess++;
            if (result.equals(&quot;kill&quot;)) {
                isAlive = false;
                System.out.println(&quot;You took &quot; + numOfGuess + &quot; guesses&quot;);
            }
        }

    }

}
</code></pre><h4 id="GameHelper"><a href="#GameHelper" class="headerlink" title="GameHelper"></a>GameHelper</h4><pre><code>import java.io.*;
public class GameHelper {
    public String getUserInput(String prompt) {
        String inputline = null;
        System.out.print(prompt + &quot;  &quot;);
        try {
            BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                inputline = is.readLine();
            if (inputline.length() ==  0)  return null;
        } catch (IOException e) {
            System.out.println(&quot;IOException: &quot; + e);
        }
        return inputline;
    }
}
</code></pre><h4 id="一个bug（下篇文章处理）"><a href="#一个bug（下篇文章处理）" class="headerlink" title="一个bug（下篇文章处理）"></a>一个bug（下篇文章处理）</h4><p><img src="http://osakbqq1v.bkt.clouddn.com/simpledc.png" alt="bug"></p>
<h1 id="新知识点"><a href="#新知识点" class="headerlink" title="新知识点"></a>新知识点</h1><ul>
<li>使用Interger.parseInt()来取得Ttring的整数值；</li>
<li>str.equal(str2)来比较两个字符串； </li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/02/Java封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/02/Java封装/" itemprop="url">Java封装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T19:47:44+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java封装"><a href="#Java封装" class="headerlink" title="Java封装"></a>Java封装</h1><h2 id="为什么要封装？"><a href="#为什么要封装？" class="headerlink" title="为什么要封装？"></a>为什么要封装？</h2><p>数据如果不封装会<strong>暴露实例变量</strong>，导致泄露资料，或被人恶意修改。<br>暴露的意思是可通过圆点运算符来存取，例如：  </p>
<pre><code>dog.size = 80;  
</code></pre><p>别人可以把值修改为任意值，不安全。</p>
<h2 id="保护数据的方法：数据隐藏"><a href="#保护数据的方法：数据隐藏" class="headerlink" title="保护数据的方法：数据隐藏"></a>保护数据的方法：数据隐藏</h2><p>使用<strong>public</strong>和<strong>private</strong>这两个存取修饰符。<br>封装的基本原则：  </p>
<ol>
<li>将实例变量标记为私有（private）；</li>
<li>提供公有（public）的方法来控制存取动作。  </li>
</ol>
<pre><code>//GoodDog.java  封装
public class GoodDog {
    private int size; //不能通过点运算符修改

    public int getSize() {
        return size;
    }

    public void setSize(int s) {
        size = s;
    }

    void bark() {
        if (size &gt; 60) {
            System.out.println(&quot;Woof!Woof!&quot;);
        } else if (size &gt; 14) {
            System.out.println(&quot;Ruff!Ruff!&quot;);
        } else {
            System.out.println(&quot;Yip!Yip!&quot;);
        }
    }

}
</code></pre><hr>
<pre><code>public class GoodDogTest {

    public static void main(String[] args) {
        GoodDog one = new GoodDog();
        one.setSize(70);

        GoodDog two = new GoodDog();
        two.setSize(8);

        System.out.println(&quot;Dog one: &quot; + one.getSize());
        System.out.println(&quot;Dog two: &quot; + two.getSize());

        one.bark();
        two.bark();
    }

}    
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/02/Java对象引用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/02/Java对象引用/" itemprop="url">Java对象引用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T19:33:25+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java对象引用"><a href="#Java对象引用" class="headerlink" title="Java对象引用"></a>Java对象引用</h1><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_0539.JPG" alt="对象引用">  </p>
<pre><code>public class Dog {
    String name;
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Dog dog1 = new Dog();
        dog1.bark();
        dog1.name = &quot;Bart&quot;;

        //创建Dog数组
        Dog[] myDogs = new Dog[3];

        myDogs[0] = new Dog();
        myDogs[1] = new Dog();
        myDogs[2] = dog1;

        myDogs[0].name = &quot;Fred&quot;;
        myDogs[1].name = &quot;Marge&quot;;

        System.out.print(&quot;Last dog&apos;s name is &quot;);
        System.out.println(myDogs[2].name);

        int x = 0;
        while (x &lt; myDogs.length) {
            myDogs[x].bark();
            x = x + 1;
        }

        dog1.name = &quot;Bob&quot;;
        dog1.bark();
        myDogs[2].bark();

    }

    public void bark() {
        System.out.println(name + &quot; says ruff!&quot;);
    }

}    
</code></pre><p>程序运行结果：<br><img src="http://osakbqq1v.bkt.clouddn.com/dog.png" alt="运行结果">  </p>
<ul>
<li>对象引用类似于指针，声明的类型不可改变；</li>
<li>myDogs[2] = dog1；两个变量指向同一个Dog对象，<strong>改变其中一个，另一个的值也会变</strong>；</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/02/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/02/Java基础/" itemprop="url">Java基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T19:15:52+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java的程序结构"><a href="#Java的程序结构" class="headerlink" title="Java的程序结构"></a>Java的程序结构</h1><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_0538.JPG" alt="Java程序结构">  </p>
<h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p>源文件（.java）带有类的定义。类用来表示程序的一个组件，小程序或许只有一个类。类的内容必须包在花括号里。  </p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类中带有一个或多个方法。在Dog这个类中，bark方法带有如何“汪汪”的指令。方法必须在类的内部声明。  </p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在方法的花括号中编写方法应该执行的指令。方法代码是由一组语句所组成，可以把方法想象成一个函数或过程。  </p>
<h2 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h2><p>当Java虚拟机启动执行时，它会寻找你在命令列所指定的类。然后它会锁定一个特定的方法：  </p>
<pre><code>public static void main(String[] args) {
    //程序。。。
}  
</code></pre><p>接着Java虚拟机就会执行main方法在花括号间的函数所有指令。<strong>每个Java程序最少都会有一个类以及一个main()。每个应用程序只有一个main()函数。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Xu Chen" />
          <p class="site-author-name" itemprop="name">Xu Chen</p>
           
              <p class="site-description motion-element" itemprop="description">programming self-learner</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xu Chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
