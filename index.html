<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="programming self-learner">
<meta property="og:type" content="website">
<meta property="og:title" content="Thierryxc 的博客">
<meta property="og:url" content="http://thierryxc.github.io/index.html">
<meta property="og:site_name" content="Thierryxc 的博客">
<meta property="og:description" content="programming self-learner">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Thierryxc 的博客">
<meta name="twitter:description" content="programming self-learner">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://thierryxc.github.io/"/>





  <title>Thierryxc 的博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Thierryxc 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每天进步一点点</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/16/Java网络与线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/16/Java网络与线程/" itemprop="url">Java网络与线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-16T18:16:03+08:00">
                2017-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="客户端要解决的三个问题"><a href="#客户端要解决的三个问题" class="headerlink" title="客户端要解决的三个问题"></a>客户端要解决的三个问题</h2><ol>
<li>建立客户端与服务器之间的初始连接：用户通过socket连接来连接服务器。</li>
<li>用户送出信息给服务器。</li>
<li>用户从服务器接受信息。</li>
</ol>
<h2 id="建立Socket连接"><a href="#建立Socket连接" class="headerlink" title="建立Socket连接"></a>建立Socket连接</h2><p>Socket是个代表两台机器之间网络连接的对象（java.net.Socket）。要创建Socket连接要知道两项关于服务器的信息：IP地址和端口号。<br>Socket连接的建立代表两台机器之间存有对方的信息，包括网络地址和TCP的端口号。</p>
<h2 id="使用BufferedReader从Socket上读取数据"><a href="#使用BufferedReader从Socket上读取数据" class="headerlink" title="使用BufferedReader从Socket上读取数据"></a>使用BufferedReader从Socket上读取数据</h2><p>用串流来通过Socket连接来沟通。</p>
<ol>
<li><p>建立对服务器的Socket连接</p>
<pre><code>Socket chatSocket = new Socket(&quot;127.0.0.1&quot;, 5000);
</code></pre></li>
<li><p>建立连接到Socket上底层输入串流的InputStreamReader</p>
<pre><code>InputStreamReader stream = new InputStreamReader(chatSocket.getInputStream());
</code></pre></li>
<li><p>建立BufferedReader来读取</p>
<pre><code>BufferedReader reader = new BufferedReader(stream);
String message = read.readline();
</code></pre></li>
</ol>
<h2 id="用PrintWriter写数据到Socket上"><a href="#用PrintWriter写数据到Socket上" class="headerlink" title="用PrintWriter写数据到Socket上"></a>用PrintWriter写数据到Socket上</h2><ol>
<li><p>对服务器建立Socket连接</p>
<pre><code>Socket chatSocket = new Socket(&quot;127.0.0.1&quot;, 5000);
</code></pre></li>
<li><p>建立链接到Socket的PrintWriter</p>
<pre><code>PrintWriter writer = new PrintWriter(chatSocket.getInputStream());
</code></pre></li>
<li><p>写入数据</p>
<pre><code>writer.println(&quot;message to send&quot;);
writer.print(&quot;anther message&quot;);
</code></pre></li>
</ol>
<h2 id="简单的客户端程序"><a href="#简单的客户端程序" class="headerlink" title="简单的客户端程序"></a>简单的客户端程序</h2><pre><code>import java.io.*;
import java.net.*;

public class DailyAdviceClient {

    public void go() {
        try {
            Socket s = new Socket(&quot;127.0.0.1&quot;, 4242);

            InputStreamReader streamReader = new InputStreamReader(s.getInputStream());
            BufferedReader reader = new BufferedReader(streamReader);

            String advice = reader.readLine();
            System.out.println(&quot;Today you should:&quot; + advice);

            reader.close();
        } catch (IOException ex) {
            ex.getStackTrace();
        }
    }

    public static void main(String[] args) {
        DailyAdviceClient client = new DailyAdviceClient();
        client.go();
    }

}
</code></pre><h2 id="编写简单的服务器程序"><a href="#编写简单的服务器程序" class="headerlink" title="编写简单的服务器程序"></a>编写简单的服务器程序</h2><pre><code>import java.io.*;
import java.net.*;

public class DailyAdviceServer {
    String[] adviceList = { &quot;go to school&quot;, &quot;go home&quot;, &quot;go to a moive&quot; };

    public void go() {
        try {
            ServerSocket serverSock = new ServerSocket(4242);//ServerSocket会监听客户端对这台机器4242端口上的要求

            //服务器进入循环等待服务客户端的请求
            while (true) {

                Socket sock = serverSock.accept(); //这个方法等待用户的时候停下来闲置，客户链接时返回一个Socket对象（与serverSock不同的端口）以便与客户端通信

                PrintWriter writer = new PrintWriter(sock.getOutputStream());
                String advice = adviceList[(int) (Math.random() * adviceList.length)];
                writer.println(advice);
                writer.close();
            }
        } catch (IOException ex) {
        ex.getStackTrace();
        }
    }
    public static void main(String[] args) {
        DailyAdviceServer server = new DailyAdviceServer();
        server.go();
    }
}
</code></pre><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>线程是独立的线程。它代表独立的执行空间。<br>Thread是Java中用来表示线程的类。要建立线程就要创建Thread。</p>
<h2 id="启动新的线程"><a href="#启动新的线程" class="headerlink" title="启动新的线程"></a>启动新的线程</h2><ol>
<li><p>建立Runnable对象（线程的任务）</p>
<pre><code>Runnable threadJob = new MyRunnable();
</code></pre></li>
<li><p>建立Thread对象（执行者）并赋值Runnable（任务）  </p>
<pre><code>Thread myThread = new Thread(threadJob);
</code></pre><p>把Runnable对象传给Thread的构造函数。这会告诉Thread对象要把哪个方法放在执行空间去运行（Runnable的run()方法）</p>
</li>
<li><p>启动Thread</p>
<pre><code>myThread.start();
</code></pre></li>
</ol>
<h3 id="实现Runnable接口来建立给thread运行的任务"><a href="#实现Runnable接口来建立给thread运行的任务" class="headerlink" title="实现Runnable接口来建立给thread运行的任务"></a>实现Runnable接口来建立给thread运行的任务</h3><pre><code>public class MyRunnable implements Runnable {
    public void run() {//必须要实现的方法，线程的任务
        go();
    }

    public void go() {
        doMore();
    }

    public void doMore() {
        System.out.println(&quot;In the thread&quot;);
    }

}
</code></pre><hr>
<pre><code>public class ThreadTester {

    public static void main(String[] args) {

        MyRunnable threadJob = new MyRunnable();
        Thread myThread = new Thread(threadJob);//将Runnable的实例传给Thread的构造函数

        myThread.start();//线程开始执行

        System.out.println(&quot;back in main&quot;);

    }

}
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>以小写t描述的thread是个独立的线程</li>
<li>Java中的每个线程都有独立的执行空间</li>
<li>大写T的Thread是java.lang.Thread这个类。他的对象是用来表示线程</li>
<li>Thread需要任务，任务是实现过Runnable的实例</li>
<li>Runnable接口只有一个方法</li>
<li>run()会是新线程所执行的第一项方法</li>
<li>要把Runnable传给Thread的构造函数才能启动新线程</li>
<li>线程在初始化以后还没有调用start()之前处于新建立的状态</li>
<li>调用Thread对象的start()之后，会建立出新的执行空间，它处于可执行状态等待被挑出来执行</li>
<li>当Java虚拟机的调度器选择某个线程之后它就处于执行中的状态，单处理器的机器只能有一个执行中的线程</li>
<li>有时线程会因为某些原因而被堵塞</li>
<li>调度不能保证任何的执行时间和顺序，所以你不能期待它会完全的平均分配执行。</li>
</ul>
<h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>Thread.sleep()这个静态方法可以强制线程进入等待状态到过了设定的时间为止。</li>
<li>sleep()方法可能会抛出InterruptedException异常。</li>
<li>可以用setName()方法帮线程命名，通常用来除错。</li>
<li>如果两个以上的线程存取堆上相同的对象可能会出现严重的问题（数据的损毁）。</li>
<li>要让对象在线程上有足够的安全性，就要判断出那些指令不能被分割执行。</li>
<li>使用synchronized这个关键词修饰符可以防止两个线程同时进入同一对象的同一方法。</li>
<li>每个对象都有单一的锁，单一的钥匙。这只会在对象带有同步化放方法时才有实际用途。</li>
<li>线程尝试进入同步化过的方法时必须要取得<strong>对象</strong>的钥匙，如果已经被别的线程拿走了，那就得等。</li>
<li>对象就算是有多个同步化过的方法，也还是只有<strong>一个锁</strong>。一旦某个线程进入该对象的同步化方法，其他线程就无法进入该对象的<strong>任何</strong>同步化方法。</li>
</ul>
<h1 id="简单的聊天软件程序"><a href="#简单的聊天软件程序" class="headerlink" title="简单的聊天软件程序"></a>简单的聊天软件程序</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre><code>import java.io.*;
import java.net.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleChatClient {

    JTextArea incoming;
    JTextField outgoing;
    BufferedReader reader;
    PrintWriter writer;
    Socket sock;

    public static void main(String[] args) {
        SimpleChatClient client = new SimpleChatClient();
        client.go();
    }

    public void go() {

        JFrame frame = new JFrame(&quot;Chat Client&quot;);
        JPanel mainPanel = new JPanel();
        incoming = new JTextArea(15,50);
        incoming.setLineWrap(true);
        incoming.setWrapStyleWord(true);
        incoming.setEditable(false);

        JScrollPane qScroller = new JScrollPane(incoming);
        qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        outgoing = new JTextField(20);
        JButton sendButton = new JButton(&quot;Send&quot;);
        sendButton.addActionListener(new SendButtonListener());

        mainPanel.add(qScroller);
        mainPanel.add(outgoing);
        mainPanel.add(sendButton);

        setUpNetworking();

        Thread readerThread = new Thread(new IncomingReader());
        readerThread.start();

        frame.getContentPane().add(BorderLayout.CENTER, mainPanel);
        frame.setSize(400, 500);
        frame.setVisible(true);
    }

    private void setUpNetworking() {

        try {
            sock = new Socket(&quot;127.0.0.1&quot;, 4242);
            InputStreamReader streamReader = new InputStreamReader(sock.getInputStream());
            reader = new BufferedReader(streamReader);
            writer = new PrintWriter(sock.getOutputStream());
            System.out.println(&quot;networking established&quot;);
        } catch (IOException ex) {
            ex.printStackTrace();
        }        
    }

    public class SendButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            try {
                writer.println(outgoing.getText());
                writer.flush();//强制将输出流缓冲区的数据送出
            } catch (Exception ex) {
                ex.printStackTrace();
            }

            outgoing.setText(&quot;&quot;);
            outgoing.requestFocus();
        }
    }

    public class IncomingReader implements Runnable {
        public void run() {//接收消息
            String message;
            try {

                while ((message = reader.readLine()) != null) {
                    System.out.println(&quot;Read &quot; + message);
                    incoming.append(message + &quot;\n&quot;);
                }
            } catch (Exception ex) {
                ex.getStackTrace();
            }
        }
    }
}
</code></pre><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><pre><code>import java.io.*;
import java.net.*;
import java.util.*;

public class ChatServer {

    ArrayList clientOutputStreams;

    public class ClientHandler implements Runnable {
        BufferedReader reader;
        Socket sock;

        public ClientHandler(Socket clientSocket) {
            try {
                sock = clientSocket;
                InputStreamReader isReader = new InputStreamReader(sock.getInputStream());
                reader = new BufferedReader(isReader);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }

        public void run() {
            String message;
            try {
                while ((message = reader.readLine()) != null) {//发送消息
                    System.out.println(&quot;Read &quot; + message);
                    tellEveryone(message);
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        new ChatServer().go();

    }

    public void go() {
        clientOutputStreams = new ArrayList();
        try {
            ServerSocket serverSock = new ServerSocket(4242);

            while (true) {//主线程接收消息，并将消息加入发送队列

                Socket clientSock =    serverSock.accept();
                PrintWriter writer = new PrintWriter(clientSock.getOutputStream());
                clientOutputStreams.add(writer);

                Thread t = new Thread(new ClientHandler(clientSock));
                t.start();
                System.out.println(&quot;Got a connection&quot;);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public void tellEveryone(String message) {

        Iterator it = clientOutputStreams.iterator();//迭代器
        while (it.hasNext()) {
            try {
                PrintWriter writer = (PrintWriter) it.next();
                writer.println(message);
                writer.flush();
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/14/Java序列化和文件的输入-输出/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/Java序列化和文件的输入-输出/" itemprop="url">Java序列化和文件的输入/输出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T12:37:55+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>将被序列化的对象写到文件中，可以通过解序列化重新读取这些对象，适用于Java环境，不能被其他程序引用。</p>
<h2 id="将序列化程序写入文件"><a href="#将序列化程序写入文件" class="headerlink" title="将序列化程序写入文件"></a>将序列化程序写入文件</h2><ol>
<li><p>创建出FileOutputStream  </p>
<pre><code>FileOutputStream fileStream = new FileOutputStream(&quot;MyGame.ser&quot;);
</code></pre><p>这一步创建存取文件的 FileOutputStream对象，如果文件不存在会自动创建。</p>
</li>
<li><p>创建ObjectOutputStream  </p>
<pre><code>ObjectOutputStream os = new ObjectOutputStream(fileStream);
</code></pre><p>这一步将对象写入ObjectOutputStream，ObjectOutputStream无法直接连接文件，需要参数引导。</p>
</li>
<li><p>写入对象</p>
<pre><code>os.writeObject(CharaerOne);//将变量所引用的对象序列化并写入文件
os.writeObject(CharaerTwo);//将变量所引用的对象序列化并写入文件
os.writeObject(CharaerThree);//将变量所引用的对象序列化并写入文件
</code></pre></li>
<li><p>关闭ObjectOutputStream </p>
<pre><code>os.close();//关闭所关联的串流
</code></pre></li>
</ol>
<h2 id="数据在串流中移动"><a href="#数据在串流中移动" class="headerlink" title="数据在串流中移动"></a>数据在串流中移动</h2><p>将串流（stream）连接起来代表来源与目的地的连接。串流必须连接到某处才能算是串流。<br>一般来说，串流要两两连接才能做出有意义的事情——其中一个表示连接，另一个则是要被调用方法的。以FileOutputStream为例，它有可以写入字节的方法。但我们通常不会直接写字节，而是以对象层次的观点来写入，所以需要高层的连接串流。</p>
<h2 id="如果要让类序列化，就要实现Serializable接口"><a href="#如果要让类序列化，就要实现Serializable接口" class="headerlink" title="如果要让类序列化，就要实现Serializable接口"></a>如果要让类序列化，就要实现Serializable接口</h2><p>Serializable接口没有任何方法要实现，它的唯一目的就是声明有实现它的类是可以被序列化的。</p>
<h2 id="序列化是全有或全无的"><a href="#序列化是全有或全无的" class="headerlink" title="序列化是全有或全无的"></a>序列化是全有或全无的</h2><p>整个对象的主数据类型实例变量和引用到其他对象的实例变量都必须正确的序列化，不然就全部失败。  </p>
<p>如果某<strong>实例变量</strong>不能或不应被实例化，就把它标记为transient（瞬时）的。 </p>
<h2 id="解序列化"><a href="#解序列化" class="headerlink" title="解序列化"></a>解序列化</h2><ol>
<li><p>创建FileInputStream</p>
<pre><code>FileInputStream fileStream = new FileInputStream(&quot;MyGame.ser&quot;);//若文件不存在则抛出异常
</code></pre></li>
</ol>
<p>FileInputStream知道如何连接文件</p>
<ol>
<li><p>创建ObjectInputStream</p>
<pre><code>ObjectInputStream os = new ObjectInputStream(fileStream);
</code></pre></li>
</ol>
<p>ObjectInputStream知道如何读取对象，但是要靠链接的stream提供文件存取</p>
<ol>
<li><p>读取对象</p>
<pre><code>Object one = os.readObject(); //每次调用readObject()都会从stream中读出下一个对象，读取顺序与读入顺序相同，次数超过会抛出异常
Object two = os.readObject();
Object three = os.readObject();
</code></pre></li>
<li><p>转换对象类型</p>
<pre><code>GameCharacter elf = (GameCharacte) one;
GameCharacte troll = (GameCharacte) two;
GameCharacte magician = (GameCharacte) three;
</code></pre></li>
<li><p>关闭ObjectInputStream</p>
<pre><code>os.close();//FileInputStream也会关掉
</code></pre></li>
</ol>
<h2 id="存储与恢复游戏人物"><a href="#存储与恢复游戏人物" class="headerlink" title="存储与恢复游戏人物"></a>存储与恢复游戏人物</h2><pre><code>import java.io.*;

public class GameSaverTest {

    public static void main(String[] args) {
        GameCharacter one = new GameCharacter(50, &quot;Elf&quot;, new String[] { &quot;bow&quot;, &quot;sword&quot; });
        GameCharacter two = new GameCharacter(50, &quot;Magic&quot;, new String[] { &quot;cust&quot;, &quot;sword&quot; });
        GameCharacter three = new GameCharacter(50, &quot;Knight&quot;, new String[] { &quot;horse&quot;, &quot;sword&quot; });

        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;Game.ser&quot;));
            os.writeObject(one);
            os.writeObject(two);
            os.writeObject(three);
            os.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }

        one = null;
        two = null;
        three = null;

        try {
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;Game.ser&quot;));
            GameCharacter oneRestore = (GameCharacter) is.readObject();
            GameCharacter twoRestore = (GameCharacter) is.readObject();
            GameCharacter threeRestore = (GameCharacter) is.readObject();

            System.out.println(oneRestore.getType());
            System.out.println(twoRestore.getType());
            System.out.println(threeRestore.getType());
        } catch (Exception ex) {
            ex.getStackTrace();
        }
    }

}
</code></pre><hr>
<pre><code>import java.io.*;

public class GameCharacter implements Serializable {
    int power;
    String type;
    String[] weapons;

    public GameCharacter(int p, String t, String[] w) {
        power = p;
        type = t;
        weapons = w;
    }

    public int getPower() {
        return power;
    }

    public String getType() {
        return type;
    }

    public String getWeapons() {
        String weaponList = &quot;&quot;;

        for (int i = 0; i &lt; weapons.length; i++) {
            weaponList += weapons[i] + &quot; &quot;;
        }

        return weaponList;
    }
}
</code></pre><h2 id="序列化要点"><a href="#序列化要点" class="headerlink" title="序列化要点"></a>序列化要点</h2><ul>
<li>你可以通过序列化来存储对象的状态</li>
<li>使用ObjectOutputStream来序列化对象（java.io）</li>
<li>Stream是<strong>连接串流</strong>或是<strong>链接</strong>用的串流</li>
<li>连接串流用来表示源或目的地、文件、网络套接字连接</li>
<li><strong>链接用串流</strong>用来衔接连接串流</li>
<li>用FileOutputStream链接ObjectOutputStream来将对象序列化到文件上</li>
<li>调用ObjectOutputStream的writeObject（theObject）来将对象序列化，不需要调用FileOutputStream的方法</li>
<li>对象必须实现序列化这个接口(Serializable)才能被序列化。如果父类实现序列化，则子类也就自动地实现，而不管是否有明确的声明</li>
<li>当对象被序列化时，整个对象版图都会被序列化。这代表它的实例变量所引用的对象也会被实例化</li>
<li>如果有不能被序列化的对象，执行期间就会抛出异常</li>
<li>若实例变量被标记为transient。该变量在还原的时候会被赋予null或主数据类型的默认值</li>
<li>在解序列化时，所有的类都必须能让Java虚拟机找到</li>
<li>读取对象的顺序必须与写入的顺序相同</li>
<li>readObject()的返回类型是Object，因此解序列化回来的对象还需要转换成原来的类型</li>
<li>静态变量不会被序列化，因为所有对象都是共享同一份静态变量值</li>
</ul>
<h1 id="文件输入-输出"><a href="#文件输入-输出" class="headerlink" title="文件输入/输出"></a>文件输入/输出</h1><h2 id="将字符串写入文件"><a href="#将字符串写入文件" class="headerlink" title="将字符串写入文件"></a>将字符串写入文件</h2><p>使用FileWriter将文本数据（字符串）写入文件</p>
<pre><code>import java.io.*;

public class WriteAFile {

    public static void main(String[] args) {

        try {
            FileWriter writer = new FileWriter(&quot;Foo.txt&quot;);//如果没有就会创建

            writer.write(&quot;Hello Foo&quot;);

            writer.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

}
</code></pre><h2 id="文本文件范例：e-Flashcard"><a href="#文本文件范例：e-Flashcard" class="headerlink" title="文本文件范例：e-Flashcard"></a>文本文件范例：e-Flashcard</h2><p>使用三个类来写电子版flashcard：  </p>
<ol>
<li>QuizCardBuilder，设计并存储卡片的工具</li>
<li>QuizCardPlayer，加载并播放卡片的引擎</li>
<li>QuizCard，表示卡片数据的类</li>
</ol>
<h3 id="QuizCard"><a href="#QuizCard" class="headerlink" title="QuizCard"></a>QuizCard</h3><pre><code>public class QuizCard {
    private String question;
    private String answer;

    public QuizCard (String q, String a) {
        question = q;
        answer = a;
    }

    public String getQuestion() {
        return question;
    }

    public String getAnswer() {
        return answer;
    }
}
</code></pre><h3 id="QuizCardBuilder"><a href="#QuizCardBuilder" class="headerlink" title="QuizCardBuilder"></a>QuizCardBuilder</h3><pre><code>import java.util.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.*;
import java.io.*;

public class QuizCardBuilder {

    private JTextArea question;
    private JTextArea answer;
    private ArrayList&lt;QuizCard&gt; cardList;
    private JFrame frame;

    public static void main(String[] args) {
        QuizCardBuilder builder = new QuizCardBuilder();
        builder.go();
    }

    public void go() {

        frame = new JFrame(&quot;Quiz Card Builder&quot;);
        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        Font bigFont = new Font(&quot;sanserif&quot;, Font.BOLD, 24);
        question = new JTextArea(6,20);
        question.setLineWrap(true);//设置在行过长的时候是否要换行
        question.setWrapStyleWord(true);//设置在单词过长的时候是否要把长单词移到下一行
        question.setFont(bigFont);

        JScrollPane qScroller = new JScrollPane(question);
        qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        answer = new JTextArea(6,20);
        answer.setLineWrap(true);//设置在行过长的时候是否要换行
        answer.setWrapStyleWord(true);//设置在单词过长的时候是否要把长单词移到下一行
        answer.setFont(bigFont);

        JScrollPane aScroller = new JScrollPane(answer);
        aScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        aScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        JButton nextButton = new JButton(&quot;Next Card&quot;);

        cardList = new ArrayList&lt;QuizCard&gt;();

        JLabel qLabel = new JLabel(&quot;Question:&quot;);
        qLabel.setFont(bigFont);
        JLabel aLabel = new JLabel(&quot;Answer:&quot;);
        aLabel.setFont(bigFont);

        mainPanel.add(qLabel);
        mainPanel.add(qScroller);
        mainPanel.add(aLabel);
        mainPanel.add(aScroller);
        mainPanel.add(nextButton);
        nextButton.addActionListener(new NextCardListener());

        JMenuBar menuBar = new JMenuBar();
        JMenu fileMenu = new JMenu(&quot;File&quot;);
        JMenuItem newMenuItem = new JMenuItem(&quot;New&quot;);
        JMenuItem saveMenuItem = new JMenuItem(&quot;Save&quot;);

        newMenuItem.addActionListener(new NewMenuListener());
        saveMenuItem.addActionListener(new SaveMenuListener());

        fileMenu.add(newMenuItem);
        fileMenu.add(saveMenuItem);
        menuBar.add(fileMenu);

        frame.setJMenuBar(menuBar);
        frame.getContentPane().add(BorderLayout.CENTER, mainPanel);
        frame.setSize(500, 600);
        frame.setVisible(true);        
    }

    public class NextCardListener implements ActionListener { 
        public void actionPerformed (ActionEvent ev) {
            QuizCard card = new QuizCard(question.getText(), answer.getText());
            cardList.add(card);
            clearCard();
        }
    }

    public class SaveMenuListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            QuizCard card = new QuizCard(question.getText(), answer.getText());
            cardList.add(card);

            JFileChooser fileSave = new JFileChooser();
            fileSave.showSaveDialog(frame);
            saveFile(fileSave.getSelectedFile());
        }
    }

    public class NewMenuListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            cardList.clear();
            clearCard();
        }
    }

    private void clearCard() {
        question.setText(&quot;&quot;);
        answer.setText(&quot;&quot;);
        question.requestFocus();
    }

    private void saveFile(File file) {
        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(file));

            for(QuizCard card : cardList) {
                writer.write(card.getQuestion() + &quot;/&quot;);
                writer.write(card.getAnswer() + &quot;\n&quot;);
            }
            writer.close();

        } catch (IOException ex) {
            System.out.println(&quot;couldn&apos;t write the cardlist out&quot;);
            ex.getStackTrace();
        }
    }
}
</code></pre><h4 id="关于JmenuBar"><a href="#关于JmenuBar" class="headerlink" title="关于JmenuBar"></a>关于JmenuBar</h4><p><img src="http://osakbqq1v.bkt.clouddn.com/Jmenu.png" alt="JMenuBar"></p>
<h3 id="java-io-File-class"><a href="#java-io-File-class" class="headerlink" title="java.io.File.class"></a>java.io.File.class</h3><p>File这个类型代表磁盘上的文件，但并不是文件中的内容。</p>
<p>可以对File做的事情：  </p>
<ol>
<li><p>创建出代表现存盘文件的File对象。</p>
<pre><code>File f = new File(&quot;MyCode.txt&quot;);
</code></pre></li>
<li><p>建立新的目录。</p>
<pre><code>File dir = new File(&quot;Chapter&quot;);
dir.mkdir();
</code></pre></li>
<li><p>列出目录下的内容。</p>
<pre><code>if (dir.isDirectory()) {
    String[] dirContents = dir.list();
    for (int i = 0; i &lt; dirContents.length; i++) {
        System.out.println(dirContents[i]); 
    }
}
</code></pre></li>
<li><p>取得文件绝对路径。</p>
<pre><code>System.out.println(dir.getAbsolutePath());
</code></pre></li>
<li><p>删除文件或目录（成功会返回true）</p>
<pre><code>bool isDeleted = f.delete();
</code></pre></li>
</ol>
<h2 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h2><pre><code>import java.io.*;

public class ReadFile {

    public static void main(String[] args) {

        try {
            File myFile = new File(&quot;MyText.txt&quot;);//找不到文件会报错
            FileReader fileReader = new FileReader(myFile);//FileReader是字符连接到文本文件的串流

            BufferedReader reader = new BufferedReader(fileReader); //将FileReader链接到BufferedReader以获得更高的效率。它只会在缓冲区读空的时候才会回头到磁盘读取

            String line = null; //用来存储获得的结果

            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            } 

            reader.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
</code></pre><h2 id="文本文件范例：e-Flashcard-1"><a href="#文本文件范例：e-Flashcard-1" class="headerlink" title="文本文件范例：e-Flashcard"></a>文本文件范例：e-Flashcard</h2><h3 id="QuizCardPlayer"><a href="#QuizCardPlayer" class="headerlink" title="QuizCardPlayer"></a>QuizCardPlayer</h3><pre><code>import java.util.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.*;
import java.io.*;

public class QuizCardPlayer {

    private JTextArea display;
    private ArrayList&lt;QuizCard&gt; cardList;
    private QuizCard currentCard;
    private int currentCardIndex;
    private JFrame frame;
    private JButton nextButton;
    private boolean isShowAnswer;

    public static void main(String[] args) {
        QuizCardPlayer reader = new QuizCardPlayer();
        reader.go();
    }

    public void go() {

        frame = new JFrame(&quot;Quiz Card Player&quot;);
        JPanel mainPanel = new JPanel();
        Font bigFont = new Font(&quot;sanserif&quot;, Font.BOLD, 24);

        display = new JTextArea(10,20);
        display.setFont(bigFont);

        display.setLineWrap(true);
        display.setEditable(false);

        JScrollPane qScroller = new JScrollPane(display);
        qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        nextButton = new JButton(&quot;Show Qusetion&quot;);

        mainPanel.add(qScroller);
        mainPanel.add(nextButton);
        nextButton.addActionListener(new NextCardListener());

        JMenuBar menuBar = new JMenuBar();
        JMenu fileMenu = new JMenu(&quot;File&quot;);
        JMenuItem loadMenuItem = new JMenuItem(&quot;Load card set&quot;);
        loadMenuItem.addActionListener(new OpenMenuListener());
        fileMenu.add(loadMenuItem);
        menuBar.add(fileMenu);

        frame.setJMenuBar(menuBar);
        frame.getContentPane().add(BorderLayout.CENTER, mainPanel);
        frame.setSize(640,500);
        frame.setVisible(true);
    }

    public class NextCardListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            if (isShowAnswer) {
                //显示答案
                display.setText(currentCard.getAnswer());
                nextButton.setText(&quot;Next Card&quot;);
                isShowAnswer = false;
            } else {
                //显示问题
                if (cardList == null){
                    System.out.println(&quot;first open a card&quot;);
                } else if (currentCardIndex &lt; cardList.size()) {
                    showNextCard();
                } else {
                    display.setText(&quot;That was last card&quot;);
                    nextButton.setEnabled(false);
                }
            }
        }
    }

    public class OpenMenuListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            JFileChooser fileOpen = new JFileChooser();//打开文件的对话框让用户选择文件
            fileOpen.showOpenDialog(frame);
            loadFile(fileOpen.getSelectedFile());
        }
    }

    private void loadFile(File file) {
        cardList = new ArrayList&lt;QuizCard&gt;();
        try {
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line = null;
            while ((line = reader.readLine()) != null) {//读取一行
                makeCard(line);//做成QuizCard加入到cardList
            }
            reader.close();
        } catch (Exception ex) {
            System.out.println(&quot;couldn&apos;t read the card file&quot;);
            ex.printStackTrace();
        }
    }

    private void makeCard(String lineToParse) {
        String[] result = lineToParse.split(&quot;/&quot;);
        QuizCard card = new QuizCard(result[0], result[1]);
        cardList.add(card);
        System.out.println(&quot;made a card&quot;);
    }

    private void showNextCard() {
        currentCard = cardList.get(currentCardIndex);
        currentCardIndex++;
        display.setText(currentCard.getQuestion());
        nextButton.setText(&quot;Show Answer&quot;);
        isShowAnswer = true;
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/12/Java-Swing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/Java-Swing/" itemprop="url">Java.Swing</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T14:03:47+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="创建GUI四个步骤回顾"><a href="#创建GUI四个步骤回顾" class="headerlink" title="创建GUI四个步骤回顾"></a>创建GUI四个步骤回顾</h1><ol>
<li><p>创建window（JFrame）。  </p>
<pre><code>JFrame frame = new JFrame();
</code></pre></li>
<li><p>创建组件。</p>
<pre><code>JButton button = new JButton();
</code></pre></li>
<li><p>把组件加到frame上。</p>
<pre><code>frame.getContentPane().add(BorderLayout.EAST, button);
</code></pre></li>
<li><p>显示出来。</p>
<pre><code>frame.setSize(300,300);
frame.setVisible(true);
</code></pre></li>
</ol>
<h1 id="布局管理器（Layout-Managers）"><a href="#布局管理器（Layout-Managers）" class="headerlink" title="布局管理器（Layout Managers）"></a>布局管理器（Layout Managers）</h1><p>布局管理器是个与特定组件相关联的Java对象，它大多数是背景组件。布局管理器用来<strong>控制所关联组件上携带的其他组件</strong>。也就是说，如果某个框架带有面板，而面板带有按钮，则面板的布局管理器控制着按钮的大小与位置，而框架的布局管理器则控制着面板的大小与位置。<br>携带就是加入到上面：  </p>
<pre><code>myPanel.add(button);  
</code></pre><h2 id="三个常用布局管理器"><a href="#三个常用布局管理器" class="headerlink" title="三个常用布局管理器"></a>三个常用布局管理器</h2><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170812_145554.jpg" alt="BorderLayout"></p>
<h2 id="BordLayout布局五个区域"><a href="#BordLayout布局五个区域" class="headerlink" title="BordLayout布局五个区域"></a>BordLayout布局五个区域</h2><pre><code>import javax.swing.*;
import java.awt.*;

public class Button1 {

    public static void main(String[] args) {
        Button1 gui = new Button1();
        gui.go();
    }

    public void go() {
        JFrame frame = new JFrame();
        JButton button = new JButton(&quot;click me..............&quot;);
        Font bigFont = new Font(&quot;serif&quot;, Font.BOLD,28);//改字体
        button.setFont(bigFont);

        frame.getContentPane().add(BorderLayout.NORTH, button);

        frame.setSize(300,300);
        frame.setVisible(true);
    }

}
</code></pre><p>总的来说：南北可以控制高度，宽度一定；东西可以控制宽度，高度一定。中间只能捡剩下的。</p>
<h2 id="FlowLayout布局组件的流向：依次从左至右，从上至下"><a href="#FlowLayout布局组件的流向：依次从左至右，从上至下" class="headerlink" title="FlowLayout布局组件的流向：依次从左至右，从上至下"></a>FlowLayout布局组件的流向：依次从左至右，从上至下</h2><p><strong>JPanel</strong>的默认布局管理器是FlowLayout。</p>
<pre><code>import javax.swing.*;
import java.awt.*;

public class Panel1 {

    public static void main(String[] args) {
        Panel1 gui = new Panel1();
        gui.go();
    }

    public void go() {
        JFrame frame = new JFrame();
        JPanel panel = new JPanel();
        panel.setBackground(Color.darkGray);

        JButton button = new JButton(&quot;shock me&quot;);
        JButton button2 = new JButton(&quot;sleep&quot;);
        JButton button3 = new JButton(&quot;go home&quot;);

        frame.getContentPane().add(BorderLayout.EAST, panel);
        panel.add(button);
        panel.add(button2);
        panel.add(button3);

        frame.setSize(300, 300);
        frame.setVisible(true);
    }

}
</code></pre><hr>
<p><img src="http://osakbqq1v.bkt.clouddn.com/folw.png" alt="flow"></p>
<h2 id="BoxLayout布局：可以指定组件排列方向"><a href="#BoxLayout布局：可以指定组件排列方向" class="headerlink" title="BoxLayout布局：可以指定组件排列方向"></a>BoxLayout布局：可以指定组件排列方向</h2><pre><code>import javax.swing.*;
import java.awt.*;

public class Panel1 {

    public static void main(String[] args) {
        Panel1 gui = new Panel1();
        gui.go();
    }

    public void go() {
        JFrame frame = new JFrame();
        JPanel panel = new JPanel();
        panel.setBackground(Color.darkGray);

        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));//构造函数要知道管理哪个组件，和用哪个轴

        JButton button = new JButton(&quot;shock me&quot;);
        JButton button2 = new JButton(&quot;sleep&quot;);
        JButton button3 = new JButton(&quot;go home&quot;);

        frame.getContentPane().add(BorderLayout.EAST, panel);
        panel.add(button);
        panel.add(button2);
        panel.add(button3);

        frame.setSize(300, 300);
        frame.setVisible(true);
    }

}
</code></pre><hr>
<p><img src="http://osakbqq1v.bkt.clouddn.com/box.png" alt="box"></p>
<h1 id="操作Swing组件"><a href="#操作Swing组件" class="headerlink" title="操作Swing组件"></a>操作Swing组件</h1><h2 id="JTextField"><a href="#JTextField" class="headerlink" title="JTextField"></a>JTextField</h2><pre><code>public class Panel1 {

    public static void main(String[] args) {
        Panel1 gui = new Panel1();
        gui.go();
    }

    public void go() {
        JFrame frame = new JFrame();
        JPanel panel = new JPanel();
        JPanel panel2 = new JPanel();
        panel.setBackground(Color.darkGray);

        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));//构造函数要知道管理哪个组件，和用哪个轴

        JButton button = new JButton(&quot;shock me&quot;);
        JButton button2 = new JButton(&quot;sleep&quot;);
        JButton button3 = new JButton(&quot;go home&quot;);
        JTextField field = new JTextField(40);//构造JTextField,参数是字款
        JLabel label = new JLabel(&quot;your name:&quot;);

        frame.getContentPane().add(BorderLayout.NORTH, panel2);
        frame.getContentPane().add(BorderLayout.EAST, panel);
        panel.add(button);
        panel.add(button2);
        panel.add(button3);

        panel2.add(label);
        panel2.add(field);

        frame.setSize(300, 300);
        frame.setVisible(true);
    }

}
</code></pre><hr>
<p><img src="http://osakbqq1v.bkt.clouddn.com/textf.png" alt="textf"></p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170812_154924.jpg" alt="method"></p>
<h2 id="JTextArea"><a href="#JTextArea" class="headerlink" title="JTextArea"></a>JTextArea</h2><p>JTextArea可以有超过一行以上的文字。如果要让JTextArea滚动，则要将它粘在ScrollPane上。</p>
<pre><code>import javax.swing.*;
import java.awt.*;

public class Panel1 {

    public static void main(String[] args) {
        Panel1 gui = new Panel1();
        gui.go();
    }

    public void go() {
        JFrame frame = new JFrame();
        JPanel panel = new JPanel();
        JPanel panel2 = new JPanel();
        panel.setBackground(Color.darkGray);

        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));//构造函数要知道管理哪个组件，和用哪个轴

        JButton button = new JButton(&quot;shock me&quot;);
        JButton button2 = new JButton(&quot;sleep&quot;);
        JButton button3 = new JButton(&quot;go home&quot;);
        JLabel label = new JLabel(&quot;your name:&quot;);

        JTextArea text = new JTextArea(10, 20);//10行高，20字宽

        JScrollPane scroller = new JScrollPane(text);//把text赋给JScrollpane
        text.setLineWrap(true);//自动换行

        scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);//只垂直滚动
        scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        panel2.add(label);
        panel2.add(scroller);

        frame.getContentPane().add(BorderLayout.CENTER, panel2);
        frame.getContentPane().add(BorderLayout.EAST, panel);
        panel.add(button);
        panel.add(button2);
        panel.add(button3);




        frame.setSize(300, 300);
        frame.setVisible(true);
    }

}
</code></pre><h3 id="一些常用方法"><a href="#一些常用方法" class="headerlink" title="一些常用方法"></a>一些常用方法</h3><ol>
<li><p>替换文字内容</p>
<pre><code>text.setText(&quot;remove&quot;);
</code></pre></li>
<li><p>加入文字</p>
<pre><code>text.append(&quot;append&quot;);
</code></pre></li>
<li><p>选取内容</p>
<pre><code>text.selectAll();
</code></pre></li>
<li><p>把GUI目前焦点拉回到文本字段以便让用户输入操作</p>
<pre><code>text.requestFocus();
</code></pre></li>
</ol>
<h3 id="JTextArea范例"><a href="#JTextArea范例" class="headerlink" title="JTextArea范例"></a>JTextArea范例</h3><pre><code>import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TextArea1  implements ActionListener {

    JFrame frame;
    JTextArea text;
    public static void main(String[] args) {
        TextArea1 gui = new TextArea1();
        gui.go();
    }

    public void go() {
        frame = new JFrame();
        JPanel panel = new JPanel();
        text = new JTextArea(10,20);
        JScrollPane scroller = new JScrollPane(text);

        text.setLineWrap(true);//自动换行

        scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);//只垂直滚动
        scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        panel.add(scroller);
        JButton button = new JButton(&quot;append sth.&quot;);
        button.addActionListener(this);

        frame.getContentPane().add(BorderLayout.CENTER,panel);
        frame.getContentPane().add(BorderLayout.SOUTH, button);

        frame.setSize(400,400);
        frame.setVisible(true);
    }

    public void actionPerformed(ActionEvent ev) {
        text.append(&quot;button clicked.\n&quot;);
    }

}
</code></pre><h2 id="JCheckBox"><a href="#JCheckBox" class="headerlink" title="JCheckBox"></a>JCheckBox</h2><pre><code>import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class CheckBox1 implements ItemListener {//监听item的事件（是否选取）
    JCheckBox box;
    JTextArea text;

    public static void main(String[] args) {
        CheckBox1 gui = new CheckBox1();
        gui.go();
    }

    public void go () {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        JPanel panel = new JPanel();
        text = new JTextArea(10,20);
        box = new JCheckBox(&quot;go home&quot;);//创建JCheckBox

        box.addItemListener(this);

        JScrollPane scroller = new JScrollPane(text);

        text.setLineWrap(true);//自动换行

        scroller.setVerticalScrollBarPolicy    、(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);//只垂直滚动
        scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        panel.add(scroller);

        panel.add(box);
        frame.getContentPane().add(BorderLayout.CENTER, panel);

        frame.setSize(400,400);
        frame.setVisible(true);
    }

    public void itemStateChanged(ItemEvent ev) {
        if (box.isSelected()) {//是否勾选
            text.append(&quot;we go home!\n&quot;);
        } else {
            text.append(&quot;no no no.\n&quot;);
        }
    }
}
</code></pre><hr>
<p><img src="http://osakbqq1v.bkt.clouddn.com/checkbox.png" alt="checkbox"></p>
<h2 id="JList"><a href="#JList" class="headerlink" title="JList"></a>JList</h2><pre><code>import javax.swing.*;
import javax.swing.event.*;//ListSelectionListener在这里！
import java.awt.*;

public class List1 implements ListSelectionListener {
    JTextField text;
    JList list;
    public static void main(String[] args) {
        List1 gui = new List1();
        gui.go();
    }

    public void go() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        JPanel panel = new JPanel();
        text = new JTextField(20);

        String [] listEntries = { &quot;actor&quot;, &quot;fireman&quot;, &quot;police&quot;, &quot;doctor&quot;, &quot;lawer&quot;,
            &quot;nurse&quot;, &quot;player&quot;, &quot;dog&quot; };
        list = new JList(listEntries);
        list.setVisibleRowCount(4);//设定显示的行数
        list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);//只能选一个
        list.addListSelectionListener(this);//对选择事件注册

        JScrollPane scroller = new JScrollPane(list);
        scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);//只垂直滚动
        scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        panel.add(scroller);
        panel.add(text);

        frame.getContentPane().add(BorderLayout.CENTER, panel);
        frame.setSize(400, 400);
        frame.setVisible(true);
        }

    public void valueChanged(ListSelectionEvent lse) {
        if (!lse.getValueIsAdjusting()) {//没有这个会得到两次事件
            String selection = (String) list.getSelectedValue();//获得选择是个Object不一定是String
            text.setText(selection);
        }
    }

}
</code></pre><hr>
<p><img src="http://osakbqq1v.bkt.clouddn.com/list.png" alt="list"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/11/Java音乐小程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/11/Java音乐小程序/" itemprop="url">Java音乐小程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-11T13:13:44+08:00">
                2017-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="创建MIDI音乐播放器"><a href="#创建MIDI音乐播放器" class="headerlink" title="创建MIDI音乐播放器"></a>创建MIDI音乐播放器</h1><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170811_132439.jpg" alt="构思"></p>
<p>要完成这个程序，我们需要用到：  </p>
<ul>
<li>JavaSound API</li>
<li>创建Swing GUI</li>
<li>通过网络链接到其他计算机</li>
<li>输入\输出数据</li>
</ul>
<h1 id="JavaSound-API"><a href="#JavaSound-API" class="headerlink" title="JavaSound API"></a>JavaSound API</h1><h2 id="MIDI"><a href="#MIDI" class="headerlink" title="MIDI"></a>MIDI</h2><p>MIDI(Musical Instrument Digital Interface)乐器数字接口，也是不同电子发声装置沟通的标准协议。<br>MIDI数据表示执行的动作，但没有实际的声音，实际声音靠装置发出。</p>
<h2 id="JavaSound的工作原理："><a href="#JavaSound的工作原理：" class="headerlink" title="JavaSound的工作原理："></a>JavaSound的工作原理：</h2><ol>
<li>取得Sequencer并将它打开。  </li>
<li>创建新的Sequence。</li>
<li>从Sequence中创建新的Track。</li>
<li>填入MidiEvent。</li>
<li>让Sequencer播放。</li>
</ol>
<pre><code>import javax.sound.midi.*;

public class MiniMiniMusicApp {

public static void main(String[] args) {
    MiniMiniMusicApp mini = new MiniMiniMusicApp();
        mini.play();
    }

    public void play() {

        try {
            //取得Sequencer并将它打开
            Sequencer player = MidiSystem.getSequencer();
            player.open();

            //创建新的Sequence
            Sequence seq = new Sequence(Sequence.PPQ, 4);

            //从Sequence中创建新的Track
            Track track = seq.createTrack();

            //填入MidiEvent
            ShortMessage a = new ShortMessage();//创建Message
            a.setMessage(144, 1, 44, 100);//置入指令（类型，频道，音符，音量）
            MidiEvent noteOn = new MidiEvent(a, 1);//在第一拍启动a
            track.add(noteOn);

            ShortMessage b = new ShortMessage();
            b.setMessage(128, 1, 44, 100);
            MidiEvent noteOff = new MidiEvent(b, 16);//在16拍停止
            track.add(noteOff);

            //将Sequence送入Sequencer
            player.setSequence(seq);

            //让Sequencer播放
            player.start();

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

}
</code></pre><h2 id="使用命令列表参数"><a href="#使用命令列表参数" class="headerlink" title="使用命令列表参数"></a>使用命令列表参数</h2><pre><code>import javax.sound.midi.*;

public class MiniMusicCmdLine {

    public static void main(String[] args) {
        MiniMusicCmdLine mini = new MiniMusicCmdLine();
        if (args.length &lt; 2) {
            System.out.println(&quot;Don&apos;t forget the instrument and note args.&quot;);
        } else {
            int instrument = Integer.parseInt(args[0]);
            int note = Integer.parseInt(args[1]);
            mini.play(instrument, note);
        }
    }

    public void play(int instrument, int note) {
        try {
            //取得Sequencer并将它打开
            Sequencer player = MidiSystem.getSequencer();
            player.open();

            //创建新的Sequence
            Sequence seq = new Sequence(Sequence.PPQ, 4);

            //从Sequence中创建新的Track
            Track track = seq.createTrack();

            MidiEvent event =null;

            ShortMessage first = new ShortMessage();
            first.setMessage(192, 1, instrument, 0);
            MidiEvent changrInstrument = new MidiEvent(first, 1);
            track.add(changrInstrument);

            //填入MidiEvent
            ShortMessage a = new ShortMessage();
            a.setMessage(144, 1, note, 100);
            MidiEvent noteOn = new MidiEvent(a, 1);
            track.add(noteOn);

            ShortMessage b = new ShortMessage();
            b.setMessage(128, 1, note, 100);
            MidiEvent noteOff = new MidiEvent(b, 16);
            track.add(noteOff);

            //将Sequence送入Sequencer
            player.setSequence(seq);

            //让Sequencer播放
            player.start();

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

}
</code></pre><h1 id="在播放音乐的同时输出图形"><a href="#在播放音乐的同时输出图形" class="headerlink" title="在播放音乐的同时输出图形"></a>在播放音乐的同时输出图形</h1><h2 id="需要实现的功能："><a href="#需要实现的功能：" class="headerlink" title="需要实现的功能："></a>需要实现的功能：</h2><ul>
<li>制作一系列MIDI信息（事件）来播放任意钢琴音</li>
<li>对事件注册一个监听者</li>
<li>开始sequencer的播放操作</li>
<li>每当监听者的事件处理程序被调用时，在面板上画出一个随机的方块并调用repaint</li>
</ul>
<h2 id="制作程序的三步："><a href="#制作程序的三步：" class="headerlink" title="制作程序的三步："></a>制作程序的三步：</h2><ol>
<li>简单的制作MIDI事件</li>
<li>注册并监听事件，但没有图形。从命令栏对应每一拍输出一个信息</li>
<li>在第二版上加上输出图形</li>
</ol>
<h2 id="制作一系列MIDI信息"><a href="#制作一系列MIDI信息" class="headerlink" title="制作一系列MIDI信息"></a>制作一系列MIDI信息</h2><pre><code>import javax.sound.midi.*;

public class MiniMusicPlayer1 {

    public static void main(String[] args) {

        try {
            //创建并打开Sequencer
            Sequencer sequencer = MidiSystem.getSequencer();
            sequencer.open();

            //创建Sequence并track
            Sequence seq = new Sequence(Sequence.PPQ, 4);
            Track track = seq.createTrack();

            for (int i = 5; i &lt; 61; i++) {
                track.add(makeEvent(144,1,i,100,i));
                track.add(makeEvent(128,1,i,100,i+2));
            }

            //开始播放
            sequencer.setSequence(seq);
            sequencer.setTempoInBPM(220);
            sequencer.start();
            } catch (Exception ex) { ex.printStackTrace(); }
    }

    public static MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        MidiEvent event = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);
        } catch (Exception e) { e.printStackTrace(); }
        return event;
        }
}
</code></pre><h2 id="第二版：加入监听事件"><a href="#第二版：加入监听事件" class="headerlink" title="第二版：加入监听事件"></a>第二版：加入监听事件</h2><pre><code>import javax.sound.midi.*;

public class MiniMusicPlayer2 implements ControllerEventListener {

    public static void main(String[] args) {
        MiniMusicPlayer2 mini = new MiniMusicPlayer2();
        mini.go();
    }

    public void go() {
        try {
            //创建并打开Sequencer
            Sequencer sequencer = MidiSystem.getSequencer();
            sequencer.open();

            int[] eventsIWant = {127};
            sequencer.addControllerEventListener(this, eventsIWant);//注册事件，监听者和监听的事件数

            //创建Sequence并track
            Sequence seq = new Sequence(Sequence.PPQ, 4);
            Track track = seq.createTrack();

            for (int i = 5; i &lt; 61; i++) {
                track.add(makeEvent(144,1,i,100,i));

                track.add(makeEvent(176,1,127,0,i));//176是ControllerEvent的编号，用来监听

                track.add(makeEvent(128,1,i,100,i+2));
            }
            sequencer.setSequence(seq);
            sequencer.setTempoInBPM(220);
            sequencer.start();
            } catch (Exception ex) { ex.printStackTrace(); }
    }

    public void controlChange(ShortMessage event) {
        System.out.println(&quot;la&quot;);
    }

    public static MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        MidiEvent event = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);
        } catch (Exception e) { e.printStackTrace(); }
        return event;
        }
}
</code></pre><h2 id="第三版：输出图形"><a href="#第三版：输出图形" class="headerlink" title="第三版：输出图形"></a>第三版：输出图形</h2><pre><code>import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 {
    static JFrame f = new JFrame(&quot;My frist music video&quot;);
    static MyDrawPanel ml;

    public static void main(String[] args) {
        MiniMusicPlayer3 mini = new MiniMusicPlayer3();
        mini.go();
    }

    public void setUpGui() {
        ml = new MyDrawPanel();
        f.setContentPane(ml);
        f.setBounds(30, 30, 300, 300);
        f.setVisible(true);
    }

    public void go() {
        setUpGui();

        try {
            //创建并打开Sequencer
            Sequencer sequencer = MidiSystem.getSequencer();
            sequencer.open();

            int[] eventsIWant = {127};
            sequencer.addControllerEventListener(ml, eventsIWant);//注册事件，监听者和监    听的事件数

            //创建Sequence并track
            Sequence seq = new Sequence(Sequence.PPQ, 4);
            Track track = seq.createTrack();

            for (int i = 5; i &lt; 61; i++) {

                int r = (int)((Math.random() * 50) + 1);
                track.add(makeEvent(144,1,r,100,i));

                track.add(makeEvent(176,1,127,0,i));//176是ControllerEvent的编号，用来监听

                track.add(makeEvent(128,1,r,100,i+2));
            }
            sequencer.setSequence(seq);
            sequencer.setTempoInBPM(220);
            sequencer.start();
            } catch (Exception ex) { ex.printStackTrace();}
    }

    public static MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        MidiEvent event = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);
        } catch (Exception e) { e.printStackTrace(); }
        return event;
    }

    class MyDrawPanel extends JPanel implements ControllerEventListener {
        boolean msg = false;

        public void controlChange(ShortMessage event) {
            msg = true;
            repaint();
        }


        public void paintComponent(Graphics g) {//只能由系统调用
            if (msg) {
                Graphics2D g2d = (Graphics2D) g;

                int red = (int) (Math.random() * 255);
                int green = (int) (Math.random() * 255);
                int blue = (int) (Math.random() * 255);

                Color color = new Color(red, green ,blue);

                g2d.setColor(color);
                int ht = (int) ((Math.random() * 120) + 10);
                int width = (int) ((Math.random() * 120) + 10);

                int x = (int) ((Math.random() * 40) + 10);
                int y = (int) ((Math.random() * 40) + 10);

                g2d.fillRect(x, y, ht, width);

                msg = false;

            }
        }
    }
}
</code></pre><h1 id="创建BeatBox"><a href="#创建BeatBox" class="headerlink" title="创建BeatBox"></a>创建BeatBox</h1><ul>
<li>创建出带有256个复选框的GUI。初始的时候这些复选框都是未勾选的，乐器的名字用到16个JLabel，还有4个按钮。</li>
<li>对4个按钮进行注册ActionListener。不需要个别监听复选框，我们不需要动态的改变样式，只需等用户点击start时再来检查复选框并制作出MIDI的track。</li>
<li>设定MIDI系统。之前已经做过，现在还要在此基础上进行循环播放，并调整播放速度。</li>
<li>在用户按下start时，真正开始程序，程序一次一行的取得复选框的状态并制作MIDI信息。持续播放直到用户取消</li>
</ul>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;  //使用ArrayList
import java.awt.event.*;

public class BeatBox {

    JPanel mainPanel;
    ArrayList&lt;JCheckBox&gt; checkboxList; //把CheckBox存在ArrayList中
    Sequencer sequencer;
    Sequence sequence;
    Track track;
    JFrame theFrame;

    String [] instrumentNames = { &quot;Bass Drum&quot;, &quot;Closed Hi-Hat&quot;, &quot;Open Hi-Hat&quot;,
            &quot;Acoustic Snare&quot;, &quot;Crash Cymbal&quot;, &quot;Hand Clap&quot;, &quot;High Tom&quot;, &quot;Hi Bongo&quot;,
            &quot;Maracas&quot;, &quot;Whistle&quot;, &quot;Low Conga&quot;, &quot;Cowbell&quot;, &quot;Vibraslap&quot;, &quot;Low-mid Tom&quot;,
            &quot;High Agogo&quot;, &quot;Open Hi Conga&quot; }; //乐器名称
    int [] instruments = { 35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63 };

    public static void main(String[] args) {
        new BeatBox().buildGUI();
    }

    public void buildGUI() {
        theFrame = new JFrame(&quot;Cyber BeatBox&quot;);//框架
        theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        BorderLayout layout = new BorderLayout();
        JPanel background = new JPanel(layout); //背景面板，设定成BoederLayout
        background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); //设定面板上的空白边缘

        checkboxList = new ArrayList&lt;JCheckBox&gt;();
        Box buttonBox = new Box(BoxLayout.Y_AXIS);

        JButton start = new JButton(&quot;start&quot;);
        start.addActionListener(new MyStartListener());
        buttonBox.add(start);

        JButton stop = new JButton(&quot;stop&quot;);
        stop.addActionListener(new MyStopListener());
        buttonBox.add(stop);

        JButton upTempo = new JButton(&quot;Tempo Up&quot;);
        upTempo.addActionListener(new MyUpTempoListener());
        buttonBox.add(upTempo);

        JButton downTempo = new JButton(&quot;Tempo Down&quot;);
        downTempo.addActionListener(new MyDownTempoListener());
        buttonBox.add(downTempo);

        Box nameBox = new Box(BoxLayout.Y_AXIS);
        for (int i = 0; i &lt; 16; i++) {
            nameBox.add(new Label(instrumentNames[i]));
        }

        background.add(BorderLayout.EAST, buttonBox);
        background.add(BorderLayout.WEST, nameBox);


        theFrame.getContentPane().add(background);

        GridLayout grid = new GridLayout(16, 16); //表格形式的布局（参数是行、列）
        grid.setVgap(10);//表格上下间距
        grid.setHgap(2);//表格左右间距
        mainPanel = new JPanel(grid);
        background.add(mainPanel);

        for (int i = 0; i &lt; 256; i++) { //创建checkbox组，设定为未勾选并加入到ArrayList和    mainPanel
            JCheckBox c = new JCheckBox();
            c.setSelected(false);
            checkboxList.add(c);
            mainPanel.add(c);
        }

        setUpMidi();

        theFrame.setBounds(50,50,400,400);
        theFrame.pack();//Frame.pack()是JAVA语言的一个函数，这个函数的作用就是根据窗口里面的    布局及组件的preferedSize来确定frame的最佳大小。
        theFrame.setVisible(true);
    }

    public void setUpMidi() {
        try {
            sequencer = MidiSystem.getSequencer();
            sequencer.open();
            sequence = new Sequence(Sequence.PPQ,4);
            track = sequence.createTrack();
            sequencer.setTempoInBPM(120);
        } catch (Exception e) { e.printStackTrace(); }
    }

    public void buildTrackAndStart() {
        int[] trackList = null;
        //去掉旧的做一个新的
        sequence.deleteTrack(track);
        track = sequence.createTrack();

        for (int i = 0; i &lt; 16; i++) {
            trackList = new int[16];

            int key = instruments[i];

            for (int j = 0; j &lt; 16; j++) {
                JCheckBox jc = (JCheckBox) checkboxList.get(j + (16 * i));
                if (jc.isSelected()) {
                    trackList[j] = key;
                } else {
                    trackList[j] = 0;
                }
            }//关闭内循环

            makeTracks(trackList);
            track.add(makeEvent(176,1,127,0,16));
        }//关闭外部循环

        track.add(makeEvent(192,9,1,0,15));//确保第16拍有事件，否则不会重复播放
        try {
            sequencer.setSequence(sequence);
            sequencer.setLoopCount(Sequencer.LOOP_CONTINUOUSLY);//重复无限此次
            sequencer.start();
            sequencer.setTempoInBPM(120);
        } catch (Exception e) { e.printStackTrace(); }
    }

    public void makeTracks(int[] list) {

        for (int i = 0; i &lt; 16; i++) {
            int key = list[i];

            if (key != 0) {
                track.add(makeEvent(144,9,key,100,i));
                track.add(makeEvent(128,9,key,100,i+1));
            }
        }
    }

    public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        MidiEvent event = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);
        } catch (Exception e) { e.printStackTrace(); }
        return event;
    }

    public class MyStartListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            buildTrackAndStart();
        }
    }

    public class MyStopListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            sequencer.stop();
        }
    }

    public class MyUpTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            float tempoFactor = sequencer.getTempoFactor();
            sequencer.setTempoFactor((float) (tempoFactor * 1.03));
        }
    }

    public class MyDownTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            float tempoFactor = sequencer.getTempoFactor();
            sequencer.setTempoFactor((float) (tempoFactor * .97));
        }
    }

}
</code></pre><h1 id="加入存取功能的BeatBox"><a href="#加入存取功能的BeatBox" class="headerlink" title="加入存取功能的BeatBox"></a>加入存取功能的BeatBox</h1><pre><code>import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;  //使用ArrayList
import java.awt.event.*;
import java.io.*;

public class BeatBox {

    JPanel mainPanel;
    ArrayList&lt;JCheckBox&gt; checkboxList; //把CheckBox存在ArrayList中
    Sequencer sequencer;
    Sequence sequence;
    Track track;
    JFrame theFrame;

    String [] instrumentNames = { &quot;Bass Drum&quot;, &quot;Closed Hi-Hat&quot;, &quot;Open Hi-Hat&quot;,
            &quot;Acoustic Snare&quot;, &quot;Crash Cymbal&quot;, &quot;Hand Clap&quot;, &quot;High Tom&quot;, &quot;Hi Bongo&quot;,
            &quot;Maracas&quot;, &quot;Whistle&quot;, &quot;Low Conga&quot;, &quot;Cowbell&quot;, &quot;Vibraslap&quot;, &quot;Low-mid Tom&quot;,
            &quot;High Agogo&quot;, &quot;Open Hi Conga&quot; }; //乐器名称
    int [] instruments = { 35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63 };

    public static void main(String[] args) {
        new BeatBox().buildGUI();
    }

    public void buildGUI() {
        theFrame = new JFrame(&quot;Cyber BeatBox&quot;);//框架
        theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        BorderLayout layout = new BorderLayout();
        JPanel background = new JPanel(layout); //背景面板，设定成BoederLayout
        background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); //设定面板上的空白边缘

        checkboxList = new ArrayList&lt;JCheckBox&gt;();
        Box buttonBox = Box.createVerticalBox();//等号后面的等价替换 new Box(BoxLayout.Y_AXIS);

        JButton start = new JButton(&quot;start&quot;);
        start.addActionListener(new MyStartListener());
        buttonBox.add(start);

        JButton stop = new JButton(&quot;stop&quot;);
        stop.addActionListener(new MyStopListener());
        buttonBox.add(stop);

        JButton upTempo = new JButton(&quot;Tempo Up&quot;);
        upTempo.addActionListener(new MyUpTempoListener());
        buttonBox.add(upTempo);

        JButton downTempo = new JButton(&quot;Tempo Down&quot;);
        downTempo.addActionListener(new MyDownTempoListener());
        buttonBox.add(downTempo);

        JButton saveTrack = new JButton(&quot;Save Track&quot;);
        saveTrack.addActionListener(new MySaveTrackListener());
        buttonBox.add(saveTrack);

        JButton restore= new JButton(&quot;Restore&quot;);
        restore.addActionListener(new MyRestoreListener());
        buttonBox.add(restore);

        Box nameBox = new Box(BoxLayout.Y_AXIS);
        for (int i = 0; i &lt; 16; i++) {
            nameBox.add(new Label(instrumentNames[i]));
        }

        background.add(BorderLayout.EAST, buttonBox);
        background.add(BorderLayout.WEST, nameBox);


        theFrame.getContentPane().add(background);

        GridLayout grid = new GridLayout(16, 16);//表格类布局
        grid.setVgap(10);//表格上下间距
        grid.setHgap(2);//表格左右间距
        mainPanel = new JPanel(grid);
        background.add(mainPanel);

        for (int i = 0; i &lt; 256; i++) { //创建checkbox组，设定为未勾选并加入到ArrayList和mainPanel
            JCheckBox c = new JCheckBox();
            c.setSelected(false);
            checkboxList.add(c);
            mainPanel.add(c);
        }

        setUpMidi();

        theFrame.setBounds(50,50,400,400);
        theFrame.pack();//Frame.pack()是JAVA语言的一个函数，这个函数的作用就是根据窗口里面的布局及组件的preferedSize来确定frame的最佳大小。
        theFrame.setVisible(true);
    }

    public void setUpMidi() {
        try {
            sequencer = MidiSystem.getSequencer();
            sequencer.open();
            sequence = new Sequence(Sequence.PPQ,4);
            track = sequence.createTrack();
            sequencer.setTempoInBPM(120);
        } catch (Exception e) { e.printStackTrace(); }
    }

    public void buildTrackAndStart() {
        int[] trackList = null;
        //去掉旧的做一个新的
        sequence.deleteTrack(track);
        track = sequence.createTrack();

        for (int i = 0; i &lt; 16; i++) {
            trackList = new int[16];

            int key = instruments[i];

            for (int j = 0; j &lt; 16; j++) {
                JCheckBox jc = (JCheckBox) checkboxList.get(j + (16 * i));
                if (jc.isSelected()) {
                    trackList[j] = key;
                } else {
                    trackList[j] = 0;
                }
            }//关闭内循环

            makeTracks(trackList);
            track.add(makeEvent(176,1,127,0,16));
        }//关闭外部循环

        track.add(makeEvent(192,9,1,0,15));//确保第16拍有事件，否则不会重复播放
        try {
            sequencer.setSequence(sequence);
            sequencer.setLoopCount(Sequencer.LOOP_CONTINUOUSLY);//重复无限此次
            sequencer.start();
            sequencer.setTempoInBPM(120);
        } catch (Exception e) { e.printStackTrace(); }
    }

    public void makeTracks(int[] list) {

        for (int i = 0; i &lt; 16; i++) {
            int key = list[i];

            if (key != 0) {
                track.add(makeEvent(144,9,key,100,i));
                track.add(makeEvent(128,9,key,100,i+1));
            }
        }
    }

    public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        MidiEvent event = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);
        } catch (Exception e) { e.printStackTrace(); }
        return event;
    }

    public class MyStartListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            buildTrackAndStart();
        }
    }

    public class MyStopListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            sequencer.stop();
        }
    }

    public class MyUpTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            float tempoFactor = sequencer.getTempoFactor();
            sequencer.setTempoFactor((float) (tempoFactor * 1.03));
        }
    }

    public class MyDownTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            float tempoFactor = sequencer.getTempoFactor();
            sequencer.setTempoFactor((float) (tempoFactor * .97));
        }
    }

    public class MySaveTrackListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            JFileChooser fileSave = new JFileChooser();
            fileSave.showSaveDialog(theFrame);
            saveFile(fileSave.getSelectedFile());
        }
    }

    private void saveFile(File file) {
        boolean[] checkboxState = new boolean[256];

        for (int i = 0; i &lt; 256; i++) {
            JCheckBox check = (JCheckBox) checkboxList.get(i);
            if (check.isSelected()) {
                checkboxState[i] = true;
            }
        }

        try {
            FileOutputStream fileStream = new FileOutputStream(file);
            ObjectOutputStream os = new ObjectOutputStream(fileStream);
            os.writeObject(checkboxState);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public class MyRestoreListener implements ActionListener {
        public void actionPerformed (ActionEvent a) {
            JFileChooser fileOpen = new JFileChooser();
            fileOpen.showOpenDialog(fileOpen);
            loadFile(fileOpen.getSelectedFile());
        }
    }

    private void loadFile(File file) {
        boolean[] checkboxState = null;
        try {
            FileInputStream fileIn = new FileInputStream(file);
            ObjectInputStream is = new ObjectInputStream(fileIn);
            checkboxState = (boolean[]) is.readObject();
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        for (int i = 0; i &lt; 256; i++) {
            JCheckBox check = (JCheckBox) checkboxList.get(i);
            if (checkboxState[i]) {
                check.setSelected(true);
            } else {
                check.setSelected(false);
            }
        }

        sequencer.stop();
        buildTrackAndStart();
    }


}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/09/Java图形用户接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/09/Java图形用户接口/" itemprop="url">Java图形用户接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T17:56:12+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h1><p>&#160; &#160; &#160; &#160;JFrame是个代表屏幕上window的对象。可以把button、checkbox、text字段等接口放在window上面。标准的menu也可以加到上面。</p>
<pre><code>import javax.swing.*;
public class SimpleGui1 {

    public static void main(String[] args) {
        JFrame frame = new JFrame(); //创建frame
        JButton button = new JButton(&quot;click me&quot;);  //创建button

        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //这一行程序会在window关闭时结束程序

        frame.getContentPane().add(button);

        frame.setSize(300, 300); //设定frame大小

        frame.setVisible(true);  //显示frame
    }

}
</code></pre><h1 id="实现按钮功能"><a href="#实现按钮功能" class="headerlink" title="实现按钮功能"></a>实现按钮功能</h1><p>实现按钮功能：  </p>
<ul>
<li>按钮要知道它的作用。</li>
<li>按钮要在按键事件发生时调用执行功能的方法。</li>
</ul>
<h2 id="取得用户的事件"><a href="#取得用户的事件" class="headerlink" title="取得用户的事件"></a>取得用户的事件</h2><p>&#160; &#160; &#160; &#160;在Java中，取得处理用户操作事件的过程称为even-handling。Java中有许多不同的事件类型，大多数都与GUI上用户的操作有关。如果用户按下了按钮，就会产生事件。</p>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>&#160; &#160; &#160; &#160;如果想要知道按钮的事件，就要监听事件的接口。<br>&#160; &#160; &#160; &#160;<strong>监听接口</strong>是介于监听和事件源间的桥梁。  </p>
<p>&#160; &#160; &#160; &#160;Swing的GUI组件是事件的来源。以Java的术语说，事件来源是个可以将用户操作（点击鼠标、关闭窗口等）转换成事件的对象。对Java而言，事件几乎都是以对象来表示（事件类对象）。<br>&#160; &#160; &#160; &#160;事件源（例如按钮）会在用户做出相关动作时（按下按钮）产生事件对象。你的程序在大多数情况下是事件的接受方而不是创建方。也就是说，你会花较多的时间当监听者而不是事件来源。<br>&#160; &#160; &#160; &#160;每个事件类型都有相对应的监听者接口，想要接收MuoseEvent的话就实现Mouse Listener这个接口。记得接口的规则：要实现接口就得声明这件事，这代表你必须把接口中<strong>所有</strong>方法都实现出来。</p>
<h2 id="监听和事件源的沟通"><a href="#监听和事件源的沟通" class="headerlink" title="监听和事件源的沟通"></a>监听和事件源的沟通</h2><h3 id="监听-1"><a href="#监听-1" class="headerlink" title="监听"></a>监听</h3><p>&#160; &#160; &#160; &#160;如果类想要知道按钮的ActionEvent，就要实现ActionListener这个接口。按钮需要知道你关注的部分，因此要通过调用addActionListener(this)并传入ActionListener的引用（下面的例子里就是你自己的这个程序，所以用this）来向按钮注册。按钮会在该事件发生时调用该接口上的方法。作为一个ActionListener，编译器会确保你实现此接口的actionPerformed()。</p>
<h3 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h3><p>&#160; &#160; &#160; &#160;按钮是ActionEvent的来源，因此它必须要知道有哪些对象是需要事件通知的。此按钮有个addActionListener()方法可以提供对事件有兴趣的对象（listener）一种表达此兴趣的方法。<br>&#160; &#160; &#160; &#160;当按钮的addActionListener()方法被调用是（因为某个listener的调用），它的参数会被按钮存到清单中。当用户按下按钮时，按钮会通过调用清单上的每个监听的actionPerformed()来启动事件。</p>
<h2 id="取得按钮的ActionEvent"><a href="#取得按钮的ActionEvent" class="headerlink" title="取得按钮的ActionEvent"></a>取得按钮的ActionEvent</h2><ol>
<li>实现ActionListener这个接口。</li>
<li>向按钮注册（告诉它你要监听事件）。</li>
<li>定义事件处理方法（实现接口的方法）。</li>
</ol>
<hr>
<pre><code>import javax.swing.*;
import java.awt.event.*;
public class SimpleGui1B implements ActionListener {
    JButton button;

    public static void main(String[] args) {
        SimpleGui1B gui = new SimpleGui1B();
        gui.go();
    }

    public void go() {
        JFrame frame = new JFrame();
        button = new JButton(&quot;Click me&quot;);

        button.addActionListener(this); //向按钮注册

        frame.getContentPane().add(button);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(300, 300);
        frame.setVisible(true);
    }

    public void actionPerformed(ActionEvent event) { //实现接口中的方法，真正处理事件的方法
        button.setText(&quot;I&apos;ve been clicked&quot;);
    }
}
</code></pre><hr>
<h1 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h1><p>在GUI上加东西的3种方法：  </p>
<ol>
<li><p><strong>在frame上放置widget：</strong><br>加上按钮、窗体、radio button 等。  </p>
</li>
<li><p><strong>在widget上绘制2D图形：</strong><br>使用graphics对象来绘制图形。</p>
</li>
<li><p><strong>在widget上放置JPEG图</strong></p>
</li>
</ol>
<h2 id="创建绘图组件"><a href="#创建绘图组件" class="headerlink" title="创建绘图组件"></a>创建绘图组件</h2><p>&#160; &#160; &#160; &#160;如果要在屏幕上放上自己的图形，最好的方式是自己创建出有绘图功能的widget。把它放在frame上，就像按钮或其他widget一样，不同之处是它会按照你所要的方式绘制。</p>
<h3 id="创建Jpanel的子类并覆盖掉paintComponent-这个方法"><a href="#创建Jpanel的子类并覆盖掉paintComponent-这个方法" class="headerlink" title="创建Jpanel的子类并覆盖掉paintComponent()这个方法"></a>创建Jpanel的子类并覆盖掉paintComponent()这个方法</h3><p>&#160; &#160; &#160; &#160;所有绘图程序代码都在paintComponent()里面。当你的panel所处的frame显示的时候，paintComponent()就会被调用。用户不能自己调用这个方法！它的参数是个跟实际屏幕有关的Graphics对象，用户无法取得这个对象，必须交由系统来交给你。然而，还是可以调用repaint()类要求系统重新绘制显示装置，然后产生paintComponent()调用。  </p>
<pre><code>import java.awt.*;
import javax.swing.*;
public class MyDrawPanel extends JPanel {//创建JPanel的子类

    public void paintComponent(Graphics g) {//只能由系统调用
        g.setColor(Color.blue);

        g.fillRect(20, 50, 100, 100);
    }
        public static void main (String[] args) {
            JFrame frame = new JFrame(); //创建frame
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            MyDrawPanel s = new MyDrawPanel();
            frame.getContentPane().add(s);

            frame.setSize(300, 300);
            frame.setVisible(true);                
        }
}
</code></pre><h3 id="其他在paintComponent-中可以做的事情"><a href="#其他在paintComponent-中可以做的事情" class="headerlink" title="其他在paintComponent()中可以做的事情"></a>其他在paintComponent()中可以做的事情</h3><h4 id="显示JPEG"><a href="#显示JPEG" class="headerlink" title="显示JPEG"></a>显示JPEG</h4><pre><code>import java.awt.*;
import javax.swing.*;
public class MyDrawPanel extends JPanel {//创建JPanel的子类

    public void paintComponent(Graphics g) {//只能由系统调用
        Image image = new ImageIcon(&quot;224888289124380709.jpg&quot;).getImage();//注意这里的根路径是project目录

        g.drawImage(image, 3, 4, this);
    }
        public static void main (String[] args) {
            JFrame frame = new JFrame(); //创建frame
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            MyDrawPanel s = new MyDrawPanel();
            frame.getContentPane().add(s);

            frame.setSize(300, 300);
            frame.setVisible(true);                
        }
}
</code></pre><h4 id="在黑色背景上画随机色彩的圆圈"><a href="#在黑色背景上画随机色彩的圆圈" class="headerlink" title="在黑色背景上画随机色彩的圆圈"></a>在黑色背景上画随机色彩的圆圈</h4><pre><code>import java.awt.*;
import javax.swing.*;
public class MyDrawPanel extends JPanel {//创建JPanel的子类

    public void paintComponent(Graphics g) {//只能由系统调用
        g.fillRect(0, 0, this.getWidth(), this.getHeight());

        int red = (int) (Math.random() * 255);
        int green = (int) (Math.random() * 255);
        int blue = (int) (Math.random() * 255);

        Color randomColor = new Color(red, green ,blue); //随机颜色
        g.setColor(randomColor); //设定画的颜色
        g.fillOval(400, 400, 200, 200);
    }
        public static void main (String[] args) {
            JFrame frame = new JFrame(); //创建frame
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            MyDrawPanel s = new MyDrawPanel();
            frame.getContentPane().add(s);

            frame.setSize(300, 300);
            frame.setVisible(true);                
        }
}
</code></pre><h3 id="使用Graphics2D对象"><a href="#使用Graphics2D对象" class="headerlink" title="使用Graphics2D对象"></a>使用Graphics2D对象</h3><p>paintComponent()的参数被声明为Graphics类型：  </p>
<pre><code>public void paintComponent(Graphics g)
</code></pre><p>因此参数g是个Graphics对象，由于多态，g也有可能是Graphics的<strong>子类</strong>。事实上，<strong>由g参数所引用的对象实际上是个Graphics2D的实例</strong>。  </p>
<p>如果要调用Graphics2D类的方法，就不能直接使用g参数。要将其转换成Graphics2D变量：  </p>
<pre><code>Graphics2D g2d = (Graphics2D) g; 
</code></pre><p>Graphics2D的方法更多：  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170810_121016.jpg" alt="2d"></p>
<pre><code>import java.awt.*;
import javax.swing.*;
public class MyDrawPanel extends JPanel {//创建JPanel的子类

    public void paintComponent(Graphics g) {//只能由系统调用
        Graphics2D g2d = (Graphics2D) g;

        int red = (int) (Math.random() * 255);
        int green = (int) (Math.random() * 255);
        int blue = (int) (Math.random() * 255);

        Color startColor = new Color(red, green ,blue);

        red = (int) (Math.random() * 255);
        green = (int) (Math.random() * 255);
        blue = (int) (Math.random() * 255);

        Color endColor = new Color(red, green ,blue);

        GradientPaint gradient = new GradientPaint(400,400, startColor,600,600, endColor);//两点之间坐标渐变
        g2d.setPaint(gradient);
        g2d.fillOval(400, 400, 200, 200);
    }
        public static void main (String[] args) {
            JFrame frame = new JFrame(); //创建frame
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            MyDrawPanel s = new MyDrawPanel();
            frame.getContentPane().add(s);

            frame.setSize(800, 800);
            frame.setVisible(true);                
        }
}
</code></pre><h1 id="在获得事件时绘制图形"><a href="#在获得事件时绘制图形" class="headerlink" title="在获得事件时绘制图形"></a>在获得事件时绘制图形</h1><h2 id="GUI布局："><a href="#GUI布局：" class="headerlink" title="GUI布局："></a>GUI布局：</h2><p>frame默认有5个区域可以安置widget：</p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170810_152529.jpg" alt="位置">   </p>
<h2 id="按下按钮圆圈就会改变颜色"><a href="#按下按钮圆圈就会改变颜色" class="headerlink" title="按下按钮圆圈就会改变颜色"></a>按下按钮圆圈就会改变颜色</h2><pre><code>import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class MySimpleGui3C implements ActionListener {
    JFrame frame;
    public static void main(String[] args) {
        MySimpleGui3C gui = new MySimpleGui3C();
        gui.go();
    }

    public void go() {
        frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(&quot;change colors&quot;);
        button.addActionListener(this);

        MyDrawPanel s = new MyDrawPanel();
        frame.getContentPane().add(BorderLayout.SOUTH, button);//两个参数的add方法可以指定位置
        frame.getContentPane().add(BorderLayout.CENTER,s);

        frame.setSize(800, 800);
        frame.setVisible(true);        


    }

    public void actionPerformed(ActionEvent event) {
        frame.repaint();
    }

} 
</code></pre><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>一个类可以嵌套在另一个类的内部。内部类可以使用外部所有的方法与变量，就算是private的也一样。</p>
<h2 id="利用内部类实现两个按钮的程序"><a href="#利用内部类实现两个按钮的程序" class="headerlink" title="利用内部类实现两个按钮的程序"></a>利用内部类实现两个按钮的程序</h2><pre><code>import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TwoButton {
    JFrame frame;
    JLabel label; //必须放在方法以外，否则是局部变量不能用
    public static void main(String[] args) {
        TwoButton gui = new TwoButton();
        gui.go();
    }

    public void go() {
        frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton labelButton = new JButton(&quot;change label&quot;);
        labelButton.addActionListener(new LabelListener());

        JButton colorButton = new JButton(&quot;change color&quot;);
        colorButton.addActionListener(new ColorListener());

        label = new JLabel(&quot;I&apos;m a label&quot;);
        MyDrawPanel drawPanel = new MyDrawPanel();

        frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
        frame.getContentPane().add(BorderLayout.EAST, labelButton);
        frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
        frame.getContentPane().add(BorderLayout.WEST, label);

        frame.setSize(800, 800);
        frame.setVisible(true);
    }

    class LabelListener implements ActionListener {//内部类，可以调用label
        public void actionPerformed(ActionEvent event) {
            label.setText(&quot;Ouch!&quot;);
        }
    }

    class ColorListener implements ActionListener {//内部类，可以调用frame
        public void actionPerformed(ActionEvent event) {
            frame.repaint();
        }
    }

}
</code></pre><h2 id="以内部类执行动画效果"><a href="#以内部类执行动画效果" class="headerlink" title="以内部类执行动画效果"></a>以内部类执行动画效果</h2><pre><code>import javax.swing.*;
import java.awt.*;

public class SimpleAnimation {
    int x = 70;
    int y = 70;

    public static void main(String[] args) {
        SimpleAnimation gui = new SimpleAnimation();
        gui.go();
    }

    public void go() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        MyDrawPanel drawPanel = new MyDrawPanel();

        frame.getContentPane().add(drawPanel);
        frame.setSize(800, 800);
        frame.setVisible(true);

        for (int i = 0; i &lt; 130; i++) {
            x++;//递增坐标值
            y++;//递增坐标值
            drawPanel.repaint();//重新绘制

            try {
                Thread.sleep(50);//加上延迟放缓过程
            } catch(Exception ex) { }
        }
    }

    class MyDrawPanel extends JPanel {
        public void paintComponent(Graphics g) {
            //去除痕迹
            g.setColor(Color.WHITE);
            g.fillRect(0, 0, this.getWidth(), this.getHeight());

            g.setColor(Color.green);
            g.fillOval(x, y, 40, 40);//x，y是椭圆左上角坐标，40，40是高度和宽度
        }
    }

}
</code></pre><p>这样使用内部类可以让外部类实现无法继承的子类的方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/09/Java异常处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/09/Java异常处理/" itemprop="url">Java异常处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T11:49:18+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>&#160; &#160; &#160; &#160;Java的异常处理（excption-handling）机制是个简洁、轻量化的执行期间例外状况处理方式。它让你能够将处理错误状况的程序代码摆在一个容易阅读的位置。这要依赖你已经知道所调用的方法是有风险的（也就是说方法可能会产生异常），因此你可以编写出处理此可能性的程序代码。如果你知道调用某个方法可能会有异常状况，你就可以预先准备好对问题的处理程序，甚或是从错误中恢复。<br>&#160; &#160; &#160; &#160;知道某个方法是否会抛出异常的方式是看该方法的声明中有没有throws语句。</p>
<h2 id="try-catch块"><a href="#try-catch块" class="headerlink" title="try/catch块"></a>try/catch块</h2><p>try/catch块告诉编译器你确实知道调用的方法有风险，并且也已经准备好处理它。  </p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul>
<li>try中内容成功，不执行catch；</li>
<li>try中不成功，跳过try中剩下部分，直接执行catch；</li>
</ul>
<h3 id="finally：无论如何都要执行的部分"><a href="#finally：无论如何都要执行的部分" class="headerlink" title="finally：无论如何都要执行的部分"></a>finally：无论如何都要执行的部分</h3><ul>
<li>如果try块失败了：抛出异常，流程马上转移到catch块。catch完成后执行finally块。</li>
<li>如果try块成功：跳过catch块，执行finally块。</li>
<li>若try或catch块有return指令，finally块<strong>还是会执行</strong>，流程会调到finally然后再回到return指令。 </li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是一种Exception类型的对象。<br>因为它是对象，所以catch住的也是对象。下面的程序代码中catch的参数是Exception类型的ex引用变量：  </p>
<pre><code>try {
    //危险动作

} catch(Exception ex) {
    //尝试恢复

}
</code></pre><p>写在catch块中的程序必定与所抛出的异常有关。</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>当你的程序代码调用有风险的方法时（也就是声明有异常的方法），就是该方法抛出异常。</p>
<h3 id="有风险、会抛出异常的程序代码："><a href="#有风险、会抛出异常的程序代码：" class="headerlink" title="有风险、会抛出异常的程序代码："></a>有风险、会抛出异常的程序代码：</h3><pre><code>public void takeRisk() throws BadException { //必须要声明它会抛出BadException
    if (abandonAllHope) {
        throw new BadException(); //创建Exception对象并抛出
    }
}
</code></pre><h3 id="调用该方法的程序代码："><a href="#调用该方法的程序代码：" class="headerlink" title="调用该方法的程序代码："></a>调用该方法的程序代码：</h3><pre><code>public void crossFingers() {
    try {
        anObject.takeRisk();
    } catch (BadException ex) {
        System.out.println(&quot;Aaargh!&quot;);
        ex.printStackTrace(); //调用此方法列出有用的信息
        }
}
</code></pre><p><strong>方法可以抓住其他方法所抛出的异常。异常总是丢回给调用方。</strong><br><strong>会抛出异常的方法必须要声明它有可能会这么做。</strong>  </p>
<h3 id="抛出一个以上异常"><a href="#抛出一个以上异常" class="headerlink" title="抛出一个以上异常"></a>抛出一个以上异常</h3><p>方法可以抛出多个异常，但在该方法的声明里必须要含有全部可能的检查异常（若两个或两个以上的异常有共同的父类时，可以只声明该父类）：</p>
<pre><code>public class Laundry {
    public void doLaundry() throws PantsException, LingerieException {
        //有可能抛出两个异常的程序代码

    }
}
</code></pre><hr>
<pre><code>public class Foo {
    public void go() {
        Laundry laundry = new Laundry();
        try {
            laundry.doLaundry();
        } catch(PantsException pex) {
            //恢复程序代码
        } catch(LingerieException lex) {
            //恢复程序代码
        }
    }
}
</code></pre><h2 id="异常也是多态的"><a href="#异常也是多态的" class="headerlink" title="异常也是多态的"></a>异常也是多态的</h2><p>如果处理各子类型异常方式不同，要单独编写，如果相同，则可以编写一个父类型的处理方式。</p>
<p>在处理多态问题时要把子类异常写在前面，因为一旦程序catch了父类异常，就不会再管其他子类异常。</p>
<h1 id="不想处理异常"><a href="#不想处理异常" class="headerlink" title="不想处理异常"></a>不想处理异常</h1><p>方法：继续抛出异常</p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170809_133715.jpg" alt="duck"></p>
<h1 id="小结：两种处理异常的方式"><a href="#小结：两种处理异常的方式" class="headerlink" title="小结：两种处理异常的方式"></a>小结：两种处理异常的方式</h1><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170809_133741.jpg" alt="小结"></p>
<h1 id="异常处理规则"><a href="#异常处理规则" class="headerlink" title="异常处理规则"></a>异常处理规则</h1><ol>
<li>catch与finally不能没有try；</li>
<li>try与catch之间不能有程序；</li>
<li>try一定要有catch或finally；</li>
<li>只带有finally的try必须要声明异常；</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/08/Java日期和时间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/08/Java日期和时间/" itemprop="url">Java日期和时间</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T14:33:01+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h1><h2 id="取得当前的日期用Date"><a href="#取得当前的日期用Date" class="headerlink" title="取得当前的日期用Date"></a>取得当前的日期用Date</h2><pre><code>import java.util.Date;
    public class DateTest {

        public static void main(String[] args) {
            //完整的日期与时间：%tc
            String s = String.format(&quot;%tc&quot;, new Date());
            System.out.println(s);

            //只有时间：%tr
            s = String.format(&quot;%tr&quot;, new Date());
            System.out.println(s);

            //周、月、日：%tA %tB %td
            Date today = new Date();
            s = String.format(&quot;%tA %tB %td&quot;, today, today, today);
            System.out.println(s);

            //不用重复给参数
            s = String.format(&quot;%tA %&lt;tB %&lt;td&quot;, today);
            System.out.println(s);
        }

}
</code></pre><p>输出：  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/date.png" alt="Date"></p>
<h2 id="操作日期用Calendar"><a href="#操作日期用Calendar" class="headerlink" title="操作日期用Calendar"></a>操作日期用Calendar</h2><h3 id="取得继承过Calendar的对象"><a href="#取得继承过Calendar的对象" class="headerlink" title="取得继承过Calendar的对象"></a>取得继承过Calendar的对象</h3><p>Calendar的实例无法取得，但是可以取得它的具体子类的实例：  </p>
<pre><code>Calendar cal = Calendar.getInstance();
</code></pre><h3 id="运用Calendar对象"><a href="#运用Calendar对象" class="headerlink" title="运用Calendar对象"></a>运用Calendar对象</h3><h4 id="几个关键概念："><a href="#几个关键概念：" class="headerlink" title="几个关键概念："></a>几个关键概念：</h4><ul>
<li>字段会保存状态：Calendar对象使用许多字段来表示某些事物的最终状态，也就是日期和时间。</li>
<li>日期和时间可以运算：Calendar的方法能够让你对不同的字段做加法或减法的运算，比如说对month字段加一个月。</li>
<li>日期与时间可以用millisecond来表示：Calendar可以让你将日期转换成微秒的表示法，或将微秒转换成日期。（相对于1970.1.1的微秒数），因此可以执行精确的相对计算。</li>
</ul>
<h4 id="运用Calendar对象："><a href="#运用Calendar对象：" class="headerlink" title="运用Calendar对象："></a>运用Calendar对象：</h4><pre><code>import java.util.Calendar;
public class CalendarTest {

    public static void main(String[] args) {
        Calendar c = Calendar.getInstance();
        c.set(2017,8,8,16,27);
        long day1 = c.getTimeInMillis();
        day1 += 1000 * 60 * 60;
        c.setTimeInMillis(day1);
        System.out.println(&quot;New hour &quot; + c.get(c.HOUR_OF_DAY));
        c.add(c.DATE, 35);
        System.out.println(&quot;add 35 days &quot; + c.getTime());
        c.roll(c.DATE, 35);
        System.out.println(&quot;roll 35 days &quot; + c.getTime());    
        c.set(c.DATE, 1);
        System.out.println(&quot;set to 1 &quot; + c.getTime());

    }

}
</code></pre><hr>
<p>输出：  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/calendar.png" alt="Calendar"></p>
<h4 id="常用的Calendar方法、字段"><a href="#常用的Calendar方法、字段" class="headerlink" title="常用的Calendar方法、字段"></a>常用的Calendar方法、字段</h4><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170808_175022.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/08/Java静态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/08/Java静态/" itemprop="url">Java静态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T12:07:16+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><p>Java是面向对象的，但若处于某种特殊情况下（通常是实用方法），则不需要类的实例。<strong>static</strong>这个关键词可以标记出不需类实例的方法。一个静态的方法就是不需要实例变量、不需要对象的行为。</p>
<h2 id="带有静态方法的含义"><a href="#带有静态方法的含义" class="headerlink" title="带有静态方法的含义"></a>带有静态方法的含义</h2><p>带有静态方法的类通常不打算要被初始化。<br>想要不让类被初始化可以有两种途径：  </p>
<ul>
<li>用abstract标记类。抽象的类不能被初始化。</li>
<li>用私有的<strong>构造函数</strong>来限制非抽象类被初始化（Math防止被初始化的方法）。  </li>
</ul>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>Math方法不需要创建Math实例就可使用，我们用的是类本身。  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170808_124552.jpg" alt="Math"></p>
<h1 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h1><p>静态变量的值对所有<strong>实例</strong>来说都相同，静态变量是被同类的所有实例共享的变量。<br>静态变量会在该类的任何<strong>静态方法</strong>执行前就初始化。（默认值与实例变量相同）  </p>
<hr>
<pre><code>public class Duck {
    private int size;
    public static int duckCount = 0;

    public Duck() {
        duckCount++;
        size = 20;
    }


    public static void main(String[] args) {
        System.out.println(Duck.duckCount);//实例创建前
        Duck d1 = new Duck();

        //类和类的实例共享静态变量

        System.out.println(d1.duckCount);
        Duck d2 = new Duck();
        System.out.println(Duck.duckCount);
        Duck d3= new Duck();
        System.out.println(d2.duckCount);
    }
}
</code></pre><hr>
<p>输出：</p>
<pre><code>0
1
2
3
</code></pre><hr>
<h2 id="静态的final变量是常量"><a href="#静态的final变量是常量" class="headerlink" title="静态的final变量是常量"></a>静态的final变量是常量</h2><p>一个被标记为final的变量代表它一旦被初始化之后就不会改动，也就是说类加载之后静态final变量就一直维持原值。以Math.PI为例：  </p>
<pre><code>public static final double PI = 3.141592653589793；
</code></pre><ul>
<li>此变量被标记为public，因此可供各方读取。</li>
<li>此变量被标记为static，不需要Math实例。</li>
<li>此变量被标记为final，其值不可改变。</li>
</ul>
<h3 id="静态final变量的初始化："><a href="#静态final变量的初始化：" class="headerlink" title="静态final变量的初始化："></a>静态final变量的初始化：</h3><p><strong>静态final变量必须人工初始化。</strong></p>
<h4 id="声明的时候"><a href="#声明的时候" class="headerlink" title="声明的时候"></a>声明的时候</h4><pre><code>public class Foo {
    public static final int FOO_X = 20；
}
</code></pre><h4 id="在静态初始化程序中"><a href="#在静态初始化程序中" class="headerlink" title="在静态初始化程序中"></a>在静态初始化程序中</h4><p>静态初始化程序是一段在加载类时会执行的程序代码，它会在其它程序可以调用该类之前就执行，所以很适合放静态final变量的起始程序。  </p>
<pre><code>public class Foo {
    public static final int FOO_X；
    static {//这段程序在类被加载时执行
        FOO_X = 20；
    }
}
</code></pre><h2 id="非静态final变量"><a href="#非静态final变量" class="headerlink" title="非静态final变量"></a>非静态final变量</h2><ul>
<li>final的变量代表不能改变它的值。</li>
<li>final的方法不能被覆盖。</li>
<li>final的类不能被继承。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/07/Java构造函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/Java构造函数/" itemprop="url">Java构造函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T13:53:18+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h1><ul>
<li>栈与堆是两种Java使用的内存空间;</li>
<li>实例变量是声明在类中方法之外的地方;</li>
<li>局部变量声明在方法或方法的参数上;</li>
<li>所有局部变量都存在于栈上相对应的堆栈块中;</li>
<li>对象引用变量与primitive主数据类型变量都放在栈上;</li>
<li>不管是实例变量或局部变量，对象本身都会在堆上;</li>
</ul>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul>
<li>构造函数带有你在初始化对象时会执行的程序代码。也就是新建一个对象时就会被执行。</li>
<li>就算没有自己写构造函数，编译器也会帮你写一个（无参数，无内容的）。  </li>
</ul>
<hr>
<pre><code>public class Duck {
    int size;

    public Duck() { //没有返回类型
        size = 27; //使用默认值
    }

    public Duck(int duckSize) {
        size = duckSize;//使用参数设定
    }

    public static void main(String[] args) {
        Duck d1 = new Duck();
        Duck d2 = new Duck(24);

        System.out.println(&quot;The size of d1 is &quot; + d1.size);
        System.out.println(&quot;The size of d2 is &quot; + d2.size);

    }
}
</code></pre><p>输出：  </p>
<p><img src="http://osakbqq1v.bkt.clouddn.com/duck.png" alt="duck"></p>
<p>这个构造函数是重载的。  </p>
<p>重载构造函数的意思是代表你有一个以上的构造函数且参数都不相同。（编译器只关注参数的<strong>类型和顺序</strong>，参数的名字不重要）  </p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>实例变量保存在所属的对象中，位于堆上。</li>
<li>如果实例变量是个对对象的引用，则引用与对象都在堆上。</li>
<li>构造函数是在新建对象时执行的程序代码。</li>
<li>构造函数必须与类同名且没有返回类型。</li>
<li>可以用构造函数来初始化被创建对象的状态。</li>
<li>如果不写构造函数，编译器会自己创建一个，默认的构造函数没有参数。</li>
<li>实例变量有默认值，原始的是0/0.0/false，引用的默认值是null。</li>
</ul>
<h2 id="父类和继承与构造函数的关系"><a href="#父类和继承与构造函数的关系" class="headerlink" title="父类和继承与构造函数的关系"></a>父类和继承与构造函数的关系</h2><p>在创建新对象时，<strong>所有</strong>继承下来的构造函数都会执行。构造函数在执行的时候，第一件事是去执行他的父类的构造函数，一直连锁反映到Object类为止。  </p>
<h3 id="无参数的父类构造函数调用"><a href="#无参数的父类构造函数调用" class="headerlink" title="无参数的父类构造函数调用"></a>无参数的父类构造函数调用</h3><hr>
<pre><code>public class Animal {
    public Animal() {
        System.out.println(&quot;Making an animal.&quot;);
    }
}
</code></pre><hr>
<pre><code>public class Hippo extends Animal {
    public Hippo() {
        System.out.println(&quot;Making an Hippo.&quot;);
    }
}
</code></pre><hr>
<pre><code>public class TestHippo {
    public static void main(String[] args) {
        Hippo h = new Hippo();
    }
}
</code></pre><hr>
<p><img src="http://osakbqq1v.bkt.clouddn.com/super.png" alt="super"> </p>
<p>上面的例子是调用无参数的父类构造函数，可以交给编译器自行完成。  </p>
<h3 id="有参数的父类构造函数调用"><a href="#有参数的父类构造函数调用" class="headerlink" title="有参数的父类构造函数调用"></a>有参数的父类构造函数调用</h3><hr>
<pre><code>public  abstract class Animal {
    private String name;

    public String getName() {
        return name;
    }
    public Animal(String theName) {
        name = theName;
    }
}
</code></pre><hr>
<pre><code>public class Hippo extends Animal {
    public Hippo(String name) {//这个构造函数要求名称
        super(name);//传给Animal的构造函数

    }
}
</code></pre><hr>
<pre><code>public class TestHippo {

    public static void main(String[] args) {
        Hippo h = new Hippo(&quot;Buffy&quot;);
        System.out.println(h.getName());
    }

}
</code></pre><hr>
<p>输出：  </p>
<pre><code>Buffy
</code></pre><h3 id="this-函数"><a href="#this-函数" class="headerlink" title="this()函数"></a>this()函数</h3><ul>
<li>使用this()来从某个构造函数中调用同一个类的另外一个构造函数。</li>
<li>this()只能用在构造函数中，且必须是第一行语句。</li>
<li>super()与this()不能同时用。每个构造函数可以选择调用super()或this(),但不能同时调用。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://thierryxc.github.io/2017/08/04/Java继承、接口与多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thierryxc 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/Java继承、接口与多态/" itemprop="url">Java继承、接口与多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-04T19:27:13+08:00">
                2017-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>子类是extends父类出来的。</li>
<li>子类会继承父类所有public类型的实例变量和方法，但不会继承父类任何的private类型的实例变量和方法。</li>
<li>继承下来的方法可以被覆盖掉，但<strong>实例变量</strong>不能被覆盖。即是某个方法在子类中被覆盖过，调用时会使用覆盖过的版本。如果覆盖后想调用父类的方法，就要用super.method()。  </li>
</ul>
<h2 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h2><ul>
<li>通过提取出类间共同的抽象性，可以排除重复的程序代码而将这个部分放在父类中。这样如果有<strong>共同</strong>的部分需要改动，就只会有一个地方改动，所有子类共享。</li>
<li>继承可以确保某个父型之下的所有类都会有父型所持有的全部（可遗传的）方法，即通过继承来定义相关类间的共同协议。  </li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="回顾：一般声明引用和创建对象的方法"><a href="#回顾：一般声明引用和创建对象的方法" class="headerlink" title="回顾：一般声明引用和创建对象的方法"></a>回顾：一般声明引用和创建对象的方法</h2><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170805_132042.jpg" alt="多态1">  </p>
<h2 id="多态的运用"><a href="#多态的运用" class="headerlink" title="多态的运用"></a>多态的运用</h2><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170805_132049.jpg" alt="多态2"></p>
<p>运用多态时，引用类型可以是实际对象的<strong>父类</strong>。  </p>
<p>在方法中，参数的引用类型也可以是实际参数的<strong>父类</strong>。  </p>
<p>综上所述，通过多态，可以编写出引进新型子类也不必修改的程序。   </p>
<h2 id="覆盖的规则"><a href="#覆盖的规则" class="headerlink" title="覆盖的规则"></a>覆盖的规则</h2><p>要覆盖父类的方法时：  </p>
<ul>
<li>参数必须要一样，且返回类型必须要兼容</li>
<li>不能<strong>降低</strong>方法的存取权限  </li>
</ul>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>重载只是刚好有相同名字的<strong>不同</strong>方法，与继承和多态无关。  </p>
<h1 id="接口和多态"><a href="#接口和多态" class="headerlink" title="接口和多态"></a>接口和多态</h1><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><h3 id="声明抽象类"><a href="#声明抽象类" class="headerlink" title="声明抽象类"></a>声明抽象类</h3><pre><code>abstarct public class Canine extends Animal
{
    public void roam() { }
}
</code></pre><hr>
<pre><code>public class MakeCanine {
    public void go() {
        Canine c;  //这是可以的，使用抽象类型来声明为引用类型给多态使用
        c = new dog();
        c = new Canine();//编译器不通过：无法创建出抽象类的实例
        c.roam() 
    }
}
</code></pre><p><strong>抽象类除了被继承过之外，没有用途、没有值、没有目的。</strong>  </p>
<h3 id="抽象的方法"><a href="#抽象的方法" class="headerlink" title="抽象的方法"></a>抽象的方法</h3><p>可以将方法标记为abstract，抽象的类表明该类一定被继承过，抽象的方法一定要被覆盖过。  </p>
<p><strong>抽象的方法没有实体。</strong>  </p>
<pre><code>public abstract void eat();
</code></pre><p><strong>如果在一个类中声明了任何一个抽象的方法，就必须将该类也标记成抽象的。</strong>  </p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的源头，它是所有类的父类。  </p>
<h3 id="Object类中带有的部分方法"><a href="#Object类中带有的部分方法" class="headerlink" title="Object类中带有的部分方法"></a>Object类中带有的部分方法</h3><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170806_194641.jpg" alt="Object方法"></p>
<h3 id="使用Object多态"><a href="#使用Object多态" class="headerlink" title="使用Object多态"></a>使用Object多态</h3><pre><code>ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();
Dog aDog = new Dog();
myDogArrayList.add(aDog);

Dog d = myDogArrayList.get(0) //无法通过编译！！！不管add进去的值是什么类型的，从ArrayList&lt;Object&gt;取出的值引用类型均为Object！！！  
</code></pre><h2 id="接口（类似于纯抽象类）"><a href="#接口（类似于纯抽象类）" class="headerlink" title="接口（类似于纯抽象类）"></a>接口（类似于纯抽象类）</h2><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><pre><code>public interface Pet {
    public abstract void beFriendly();
    public abstract void Play();
}
</code></pre><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><pre><code>public class Dog extends Canine implement Pet {
    public void beFriendly() {……} //必须实现出Pet的方法
    public  void Play(){……} //必须实现出Pet的方法

    ……
}
</code></pre><h3 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h3><p><img src="http://osakbqq1v.bkt.clouddn.com/IMG_20170806_200840.jpg" alt="接口">  </p>
<p>意义还是在于<strong>多态</strong>，用接口取代具体的子类或抽象的父类作为参数或返回类型，则可以传入任何实现该接口的东西，使用接口可以继承超过一个以上的来源。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Xu Chen" />
          <p class="site-author-name" itemprop="name">Xu Chen</p>
           
              <p class="site-description motion-element" itemprop="description">programming self-learner</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xu Chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
